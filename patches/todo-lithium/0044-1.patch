From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: IPECTER <ipectert@gmail.com>
Date: Tue, 10 Jan 2023 14:54:30 +0900
Subject: [PATCH] 1


diff --git a/src/main/java/net/minecraft/world/entity/ai/Brain.java b/src/main/java/net/minecraft/world/entity/ai/Brain.java
index 88860e4b0e898f1e4a01cabcd2aaeb297e05be4e..63322883f7564ef1f6b4d28c6aa49f3d20faa197 100644
--- a/src/main/java/net/minecraft/world/entity/ai/Brain.java
+++ b/src/main/java/net/minecraft/world/entity/ai/Brain.java
@@ -81,7 +81,7 @@ public class Brain<E extends LivingEntity> {
                     mutableObject.setValue(mutableObject.getValue().apply2(ImmutableList.Builder::add, dataResult2));
                 });
                 ImmutableList<Brain.MemoryValue<?>> immutableList = mutableObject.getValue().resultOrPartial(Brain.LOGGER::error).map(ImmutableList.Builder::build).orElseGet(ImmutableList::of);
-                return DataResult.success(new Brain<>(memoryModules, sensors, immutableList, mutableObject::getValue));
+                return DataResult.success(new Brain<>(memoryModules, sensors, immutableList, () -> (Codec) mutableObject.getValue()));
             }
 
             private <T, U> DataResult<Brain.MemoryValue<U>> captureRead(MemoryModuleType<U> memoryType, DynamicOps<T> ops, T value) {
@@ -144,11 +144,14 @@ public class Brain<E extends LivingEntity> {
         return this.codec.get().encodeStart(ops, this);
     }
 
+    // Fusion - Fix Source
+    @SuppressWarnings("unchecked")
     Stream<Brain.MemoryValue<?>> memories() {
         return this.memories.entrySet().stream().map((entry) -> {
-            return Brain.MemoryValue.createUnchecked(entry.getKey(), entry.getValue());
+            return Brain.MemoryValue.createUnchecked((MemoryModuleType)entry.getKey(), (Optional)entry.getValue());
         });
     }
+    // Fusion end
 
     public boolean hasMemoryValue(MemoryModuleType<?> type) {
         return this.checkMemory(type, MemoryStatus.VALUE_PRESENT);
@@ -186,20 +189,24 @@ public class Brain<E extends LivingEntity> {
 
     }
 
+    // Fusion - Fix Source
+    @SuppressWarnings("unchecked")
     public <U> Optional<U> getMemory(MemoryModuleType<U> type) {
         Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
         if (optional == null) {
             throw new IllegalStateException("Unregistered memory fetched: " + type);
         } else {
-            return optional.map(ExpirableValue::getValue);
+            return (Optional)optional.map(ExpirableValue::getValue);
         }
     }
 
     @Nullable
+    @SuppressWarnings("unchecked")
     public <U> Optional<U> getMemoryInternal(MemoryModuleType<U> type) {
         Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
-        return optional == null ? null : optional.map(ExpirableValue::getValue);
+        return optional == null ? null : (Optional)optional.map(ExpirableValue::getValue);
     }
+    // Fusion end
 
     public <U> long getTimeUntilExpiry(MemoryModuleType<U> type) {
         Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
@@ -492,7 +499,7 @@ public class Brain<E extends LivingEntity> {
         private final MemoryModuleType<U> type;
         private final Optional<? extends ExpirableValue<U>> value;
 
-        static <U> Brain.MemoryValue<U> createUnchecked(MemoryModuleType<U> type, Optional<? extends ExpirableValue<?>> data) {
+        static <U> Brain.MemoryValue<U> createUnchecked(MemoryModuleType<U> type, Optional<? extends ExpirableValue<U>> data) { // Fusion - Fix Source
             return new Brain.MemoryValue<>(type, data);
         }
 
