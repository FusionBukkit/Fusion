From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: IPECTER <ipectert@gmail.com>
Date: Wed, 19 Oct 2022 21:56:20 +0900
Subject: [PATCH] Fusion-ZeroChunk

FartherViewDistance - XUAN - Private

diff --git a/src/main/java/com/github/ipecter/fusion/FusionConfig.java b/src/main/java/com/github/ipecter/fusion/FusionConfig.java
index 455dbb85d17b9ff5685162c3feffdd97c5907100..5e59890e1c30606993617ff5b62015ccd39e8914 100644
--- a/src/main/java/com/github/ipecter/fusion/FusionConfig.java
+++ b/src/main/java/com/github/ipecter/fusion/FusionConfig.java
@@ -1,5 +1,6 @@
 package com.github.ipecter.fusion;
 
+import com.github.ipecter.fusion.configurations.ZeroChunkConfig;
 import com.github.ipecter.fusion.configurations.LithiumConfig;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
@@ -200,4 +201,8 @@ public class FusionConfig {
     private void lithiumConfig(){
         lithiumConfig = new LithiumConfig();
     }
+    public static ZeroChunkConfig zeroChunkConfig;
+    private void zeroChunkConfig(){
+        zeroChunkConfig = new ZeroChunkConfig();
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/com/github/ipecter/fusion/FusionWorldConfig.java b/src/main/java/com/github/ipecter/fusion/FusionWorldConfig.java
index 659d3e4e9b308ac7efb41f762d6a41fb9cb0fcd1..a822a664c8c86386a9df44d74d667499d06f50f2 100644
--- a/src/main/java/com/github/ipecter/fusion/FusionWorldConfig.java
+++ b/src/main/java/com/github/ipecter/fusion/FusionWorldConfig.java
@@ -1,6 +1,7 @@
 package com.github.ipecter.fusion;
 
 import com.github.ipecter.fusion.configurations.LithiumWorldConfig;
+import com.github.ipecter.fusion.configurations.ZeroChunkWorldConfig;
 import org.apache.commons.lang.BooleanUtils;
 import org.simpleyaml.configuration.ConfigurationSection;
 import org.simpleyaml.configuration.comments.CommentType;
@@ -16,10 +17,12 @@ public class FusionWorldConfig {
 
     private final String worldName;
     public LithiumWorldConfig lithiumConfig;
+    public ZeroChunkWorldConfig zeroChunkConfig;
 
     public FusionWorldConfig(String worldName) {
         this.worldName = worldName;
         init();
         lithiumConfig = new LithiumWorldConfig(worldName);
+        zeroChunkConfig = new ZeroChunkWorldConfig(worldName);
     }
 
diff --git a/src/main/java/com/github/ipecter/fusion/configurations/ZeroChunkConfig.java b/src/main/java/com/github/ipecter/fusion/configurations/ZeroChunkConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..061d8c1fbcd0e7f304966d3caa8a4f543b3b7d5c
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/configurations/ZeroChunkConfig.java
@@ -0,0 +1,71 @@
+package com.github.ipecter.fusion.configurations;
+
+import com.github.ipecter.fusion.FusionConfig;
+import com.github.ipecter.fusion.zerochunk.data.viewmap.ViewMapMode;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class ZeroChunkConfig extends FusionConfig {
+
+    public ZeroChunkConfig(){
+        setComment("zero-chunk", "[ ZeroChunk ] Extreme Optimized View-Distance System to replace Vanilla\n" + "It Stably Supports Minimum 32 View-Distance and Maximum 128 View-Distance");
+        enable = getBoolean("zero-chunk.enable", true);
+        setComment("zero-chunk.max-view-distance","( View Distance Mode )\n"
+                + "View Distance  |  Needed RAM for View Calculate Per Player\n"
+                + " X15   =   15  |  int[  31] = byte[  124] Fastest"
+                + " X31   =   31  |  long[  63] = byte[  504] Recommend"
+                + " X63   =   63  |  long[ 254] = byte[ 2032]"
+                + " X127  =  127  |  long[1020] = byte[ 8160]"
+                + " X383  =  383  |  long[3064] = byte[24512]"
+        );
+        maxViewDistance = ViewMapMode.valueOf(getString("zero-chunk.max-view-distance", "X31").toUpperCase());
+        setComment("zero-chunk.async-thread-amount","( Number of Asynchronous Threads )\n"
+                + "Recommended value 1~10 (can also be higher)"
+        );
+        asyncThreadAmount = getInt("zero-chunk.async-thread-amount", 2);
+        setComment("zero-chunk.auto-adapt-player-network-speed", "Automatically adapt to the player internet speed");
+        autoAdaptPlayerNetworkSpeed = getBoolean("zero-chunk.auto-adapt-player-network-speed", true);
+        setComment("zero-chunk.player-network-speed-use-degree","How many player internet speed can be used (percentage)\n"
+                + "If the detected network speed is 2 MB/s, 0.6 = 60%, only 1.2 MB/s is allowed to be sent");
+        playerNetworkSpeedUseDegree = getDouble("zero-chunk.player-network-speed-use-degree", 0.6);
+        setComment("zero-chunk.server-send-second-max-bytes", "How much data can the server transmit per second (Unit bytes)\n"
+                + "Default value 20971520 bytes = 20 MB");
+        serverSendSecondMaxBytes = getInt("zero-chunk.server-send-second-max-bytes", 20971520);
+        setComment("zero-chunk.server-tick-max-generate-amount","How many chunk can the server generate per game tick\n"
+                + "When generating terrain, the CPU workload is greater\n"
+                + "Set to 0 Does not generate");
+        serverTickMaxGenerateAmount = getInt("zero-chunk.server-tick-max-generate-amount", 2);
+        setComment("zero-chunk.calculate-missing-height-map", "Calculate the missing height map\n"
+                + "Closing can reduce the amount of calculation required for each chunk\n"
+                + "But it may cause snow/rain to penetrate the ground by mistake");
+        calculateMissingHeightMap = getBoolean("zero-chunk.calculate-missing-height-map", false);
+        setComment("zero-chunk.disable-fast-process", "Don't fast process chunk\n"
+                + "Load once for each sent");
+        disableFastProcess = getBoolean("zero-chunk.disable-fast-process", false);
+        Map<String, Integer> permissionsNodeMap = new HashMap<>();
+        for (String line : (List<String>)getList("zero-chunk.node-list", new ArrayList<>())) {
+            String[] lineSplit = line.split(";", 2);
+            if (lineSplit.length != 2)
+                throw new NullPointerException("Fusion Configuration - zero-chunk.permissions.node-list - Can't find the separator \";\": " + line);
+            permissionsNodeMap.put(lineSplit[1], Integer.parseInt(lineSplit[0]));
+        }
+        permissionsNodeList = new ArrayList<>(permissionsNodeMap.entrySet());
+        permissionsPeriodicMillisecondCheck = getInt("zero-chunk.permissions.periodic-millisecond-check", 60000);
+    }
+
+    public boolean enable;
+    public ViewMapMode maxViewDistance;
+    public int asyncThreadAmount;
+    public boolean autoAdaptPlayerNetworkSpeed;
+    public double playerNetworkSpeedUseDegree;
+    public int serverSendSecondMaxBytes;
+    public int serverTickMaxGenerateAmount;
+    public boolean calculateMissingHeightMap;
+    public boolean disableFastProcess;
+    public List<Map.Entry<String, Integer>> permissionsNodeList;
+    public int permissionsPeriodicMillisecondCheck;
+
+}
diff --git a/src/main/java/com/github/ipecter/fusion/configurations/ZeroChunkWorldConfig.java b/src/main/java/com/github/ipecter/fusion/configurations/ZeroChunkWorldConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ea0f0b550c2db11cbf4cacb0b5baed440621732
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/configurations/ZeroChunkWorldConfig.java
@@ -0,0 +1,81 @@
+package com.github.ipecter.fusion.configurations;
+
+import com.github.ipecter.fusion.FusionWorldConfig;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.block.data.BlockData;
+import org.simpleyaml.configuration.ConfigurationSection;
+
+import java.util.*;
+import java.util.logging.Level;
+
+public class ZeroChunkWorldConfig extends FusionWorldConfig {
+
+    public ZeroChunkWorldConfig(String worldName){
+        super(worldName);
+        enable = getBoolean("zero-chunk.enable", true);
+        maxViewDistance = getInt("zero-chunk.max-view-distance", 31);
+        worldTickMaxGenerateAmount = getInt("zero-chunk.world-tick-max-generate-amount", 2);
+        sendTitleData = getBoolean("zero-chunk.send-title-data", true);
+        worldSendSecondMaxBytes = getInt("zero-chunk.world-send-second-max-bytes", 10485760);
+        playerSendSecondMaxBytes = getInt("zero-chunk.player-send-second-max-bytes", 2097152);
+        readServerLoadedChunk = getBoolean("zero-chunk.read-server-loaded-chunk", true);
+        delayBeforeSend = getInt("zero-chunk.delay-before-send", 5000);
+        preventXray = parsePreventXray(getConfigurationSection("zero-chunk.prevent-xray"), worldName);
+        getBoolean("zero-chunk.prevent-xray.enable", true);
+        getList("zero-chunk.prevent-xray.conversion-list.STONE", Arrays.asList("COAL_ORE", "IRON_ORE", "COPPER_ORE", "GOLD_ORE", "REDSTONE_ORE", "EMERALD_ORE", "LAPIS_ORE", "DIAMOND_ORE"));
+        getList("zero-chunk.prevent-xray.conversion-list.DEEPSLATE", Arrays.asList("DEEPSLATE_COAL_ORE", "DEEPSLATE_IRON_ORE", "DEEPSLATE_COPPER_ORE", "DEEPSLATE_GOLD_ORE", "DEEPSLATE_REDSTONE_ORE", "DEEPSLATE_EMERALD_ORE", "DEEPSLATE_LAPIS_ORE", "DEEPSLATE_DIAMOND_ORE"));
+        getList("zero-chunk.prevent-xray.conversion-list.NETHERRACK", Arrays.asList("NETHER_GOLD_ORE", "NETHER_QUARTZ_ORE", "ANCIENT_DEBRIS"));
+        getList("zero-chunk.prevent-xray.conversion-list.BLACKSTONE", Arrays.asList("GILDED_BLACKSTONE"));
+        speedingNotSend = getDouble("zero-chunk.speeding-not-send", 1.2);
+    }
+
+    public boolean enable;
+    public int maxViewDistance;
+    public int worldTickMaxGenerateAmount;
+    public boolean sendTitleData;
+    public int worldSendSecondMaxBytes;
+    public int playerSendSecondMaxBytes;
+    public boolean readServerLoadedChunk;
+    public int delayBeforeSend;
+    public Map<BlockData, BlockData[]> preventXray;
+    public double speedingNotSend;
+
+    private Map<BlockData, BlockData[]> parsePreventXray(ConfigurationSection preventXrayConfiguration, String worldName) {
+        if (preventXrayConfiguration == null) {
+            return new HashMap<>();
+        } else {
+            Map<BlockData, BlockData[]> preventXrayConversionMap = new HashMap<>();
+            if (preventXrayConfiguration.getBoolean("enable", true)) {
+                ConfigurationSection conversionConfiguration = preventXrayConfiguration.getConfigurationSection("conversion-list");
+                if (conversionConfiguration != null) {
+                    for (String toString : conversionConfiguration.getKeys(false)) {
+                        Material toMaterial = Material.getMaterial(toString.toUpperCase());
+
+                        if (toMaterial == null) {
+                            Bukkit.getLogger().log(Level.WARNING, "worlds." + worldName + ".prevent-xray - conversion-list Can't find this material: " + toString);
+                            continue;
+                        }
+
+                        List<Material> hitMaterials = new ArrayList<>();
+                        for (String hitString : conversionConfiguration.getStringList(toString)) {
+                            Material targetMaterial = Material.getMaterial(hitString.toUpperCase());
+                            if (targetMaterial == null) {
+                                Bukkit.getLogger().log(Level.WARNING, "worlds." + worldName + ".prevent-xray - conversion-list Can't find this material: " + hitString);
+                                continue;
+                            }
+                            hitMaterials.add(targetMaterial);
+                        }
+
+                        BlockData[] materials = new BlockData[hitMaterials.size()];
+                        for (int i = 0 ; i < materials.length ; ++i )
+                            materials[i] = hitMaterials.get(i).createBlockData();
+
+                        preventXrayConversionMap.put(toMaterial.createBlockData(), materials);
+                    }
+                }
+            }
+            return preventXrayConversionMap;
+        }
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/ViewDistance.java b/src/main/java/com/github/ipecter/fusion/zerochunk/ViewDistance.java
new file mode 100644
index 0000000000000000000000000000000000000000..30895fada57cb6ac650b5c831c8c56a229e91e8a
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/ViewDistance.java
@@ -0,0 +1,16 @@
+package com.github.ipecter.fusion.zerochunk;
+
+import com.github.ipecter.fusion.zerochunk.data.PlayerChunkView;
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.entity.Player;
+
+public final class ViewDistance {
+
+    private ViewDistance() {
+    }
+
+    public static PlayerView getPlayerView(Player player) {
+        PlayerChunkView view = ZeroChunk.getInstance().getView(player);
+        return view != null ? view.viewAPI : null;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/ZeroChunk.java b/src/main/java/com/github/ipecter/fusion/zerochunk/ZeroChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b9c6f9526945f015ed2f7bce0d81463dcd0e87a
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/ZeroChunk.java
@@ -0,0 +1,492 @@
+package com.github.ipecter.fusion.zerochunk;
+
+import com.github.ipecter.fusion.FusionConfig;
+import com.github.ipecter.fusion.configurations.ZeroChunkWorldConfig;
+import com.github.ipecter.fusion.zerochunk.branch.*;
+import com.github.ipecter.fusion.zerochunk.data.CumulativeReport;
+import com.github.ipecter.fusion.zerochunk.data.LangFiles;
+import com.github.ipecter.fusion.zerochunk.data.NetworkTraffic;
+import com.github.ipecter.fusion.zerochunk.data.PlayerChunkView;
+import com.github.ipecter.fusion.zerochunk.data.viewmap.ViewMap;
+import com.github.ipecter.fusion.zerochunk.data.viewmap.ViewShape;
+import com.github.ipecter.fusion.zerochunk.event.PlayerSendExtendChunkEvent;
+import com.github.ipecter.fusion.zerochunk.event.packet.PacketEvent;
+import com.github.ipecter.fusion.zerochunk.event.packet.PacketMapChunkEvent;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.scheduler.BukkitScheduler;
+import org.bukkit.scheduler.BukkitTask;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+
+public final class ZeroChunk {
+
+    private Plugin MINECRAFT = new MinecraftInternalPlugin();
+
+    private boolean running = true;
+    public final BranchMinecraft branchMinecraft = new BranchMinecraft();
+    public final BranchPacket branchPacket = new BranchPacket();
+    private final Set<BukkitTask> bukkitTasks = ConcurrentHashMap.newKeySet();
+    public final Random random = new Random();
+    private ScheduledExecutorService multithreadedService;
+    private AtomicBoolean multithreadedCanRun;
+    public final Map<Player, PlayerChunkView> playersViewMap = new ConcurrentHashMap<>();
+    private final NetworkTraffic serverNetworkTraffic = new NetworkTraffic();
+    private final Map<World, NetworkTraffic> worldsNetworkTraffic = new ConcurrentHashMap<>();
+    private List<World> lastWorldList = new ArrayList<>();
+    private final AtomicInteger serverGeneratedChunk = new AtomicInteger(0);
+    public final CumulativeReport serverCumulativeReport = new CumulativeReport();
+    private final Map<World, AtomicInteger> worldsGeneratedChunk = new ConcurrentHashMap<>();
+    public final Map<World, CumulativeReport> worldsCumulativeReport = new ConcurrentHashMap<>();
+    private final Set<Runnable> waitMoveSyncQueue = ConcurrentHashMap.newKeySet();
+    public final Map<Integer, CumulativeReport> threadsCumulativeReport = new ConcurrentHashMap<>();
+    public final Set<Thread> threadsSet = ConcurrentHashMap.newKeySet();
+    public volatile boolean globalPause = false;
+    public final LangFiles lang = new LangFiles();
+    private static final ViewShape viewShape = ViewShape.ROUND;
+
+    public ZeroChunk() {
+
+        BukkitScheduler scheduler = Bukkit.getScheduler();
+        bukkitTasks.add(scheduler.runTaskTimer(MINECRAFT, this::tickSync, 0, 1));
+        bukkitTasks.add(scheduler.runTaskTimerAsynchronously(MINECRAFT, this::tickAsync, 0, 1));
+        bukkitTasks.add(scheduler.runTaskTimerAsynchronously(MINECRAFT, this::tickReport, 0, 20));
+
+        reloadMultithreaded();
+    }
+
+    public PlayerChunkView initView(Player player) {
+        PlayerChunkView view = new PlayerChunkView(player, viewShape, branchPacket);
+        playersViewMap.put(player, view);
+        return view;
+    }
+
+    public void clearView(Player player) {
+        playersViewMap.remove(player);
+    }
+
+    public PlayerChunkView getView(Player player) {
+        return playersViewMap.get(player);
+    }
+
+    public synchronized void reloadMultithreaded() {
+        if (multithreadedCanRun != null)
+            multithreadedCanRun.set(false);
+        if (multithreadedService != null) {
+            multithreadedService.shutdown();
+        }
+        threadsCumulativeReport.clear();
+        threadsSet.clear();
+
+        playersViewMap.values().forEach(view -> view.waitSend = false);
+
+        AtomicBoolean canRun = new AtomicBoolean(true);
+        multithreadedCanRun = canRun;
+        multithreadedService = Executors.newScheduledThreadPool(FusionConfig.zeroChunkConfig.asyncThreadAmount + 1);
+
+        multithreadedService.schedule(() -> {
+            Thread thread = Thread.currentThread();
+            thread.setName("ZeroChunk View thread");
+            thread.setPriority(3);
+            threadsSet.add(thread);
+            runView(canRun);
+        }, 0, TimeUnit.MILLISECONDS);
+
+        for (int index = 0; index < FusionConfig.zeroChunkConfig.asyncThreadAmount; index++) {
+            int threadNumber = index;
+            CumulativeReport threadCumulativeReport = new CumulativeReport();
+            threadsCumulativeReport.put(index, threadCumulativeReport);
+            multithreadedService.schedule(() -> {
+                Thread thread = Thread.currentThread();
+                thread.setName("ZeroChunk AsyncTick thread #" + threadNumber);
+                thread.setPriority(2);
+                threadsSet.add(thread);
+                runThread(canRun, threadCumulativeReport);
+            }, 0, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    public void initWorld(World world) {
+        worldsNetworkTraffic.put(world, new NetworkTraffic());
+        worldsCumulativeReport.put(world, new CumulativeReport());
+        worldsGeneratedChunk.put(world, new AtomicInteger(0));
+    }
+
+    public void clearWorld(World world) {
+        worldsNetworkTraffic.remove(world);
+        worldsCumulativeReport.remove(world);
+        worldsGeneratedChunk.remove(world);
+    }
+
+    private void tickSync() {
+        List<World> worldList = Bukkit.getWorlds();
+        Collections.shuffle(worldList);
+        lastWorldList = worldList;
+        waitMoveSyncQueue.removeIf(runnable -> {
+            try {
+                runnable.run();
+            } catch (Exception exception) {
+                exception.printStackTrace();
+            }
+            return true;
+        });
+    }
+
+    private void tickAsync() {
+        serverNetworkTraffic.next();
+        worldsNetworkTraffic.values().forEach(NetworkTraffic::next);
+        playersViewMap.values().forEach(view -> {
+            view.networkTraffic.next();
+            view.networkSpeed.next();
+        });
+        serverGeneratedChunk.set(0);
+        worldsGeneratedChunk.values().forEach(generatedChunk -> generatedChunk.set(0));
+    }
+
+    private void tickReport() {
+        serverCumulativeReport.next();
+        worldsCumulativeReport.values().forEach(CumulativeReport::next);
+        playersViewMap.values().forEach(view -> view.cumulativeReport.next());
+        threadsCumulativeReport.values().forEach(CumulativeReport::next);
+    }
+
+    private void runView(AtomicBoolean canRun) {
+        while (canRun.get()) {
+            long startTime = System.currentTimeMillis();
+
+            try {
+                playersViewMap.forEach((player, view) -> {
+                    if (!view.install())
+                        view.updateDistance();
+                    view.moveTooFast = view.overSpeed();
+                });
+            } catch (Exception exception) {
+                exception.printStackTrace();
+            }
+
+            long endTime = System.currentTimeMillis();
+            long needSleep = 50 - (endTime - startTime);
+            if (needSleep > 0) {
+                try {
+                    Thread.sleep(needSleep);
+                } catch (InterruptedException ignored) {
+                }
+            }
+        }
+    }
+
+    private void runThread(AtomicBoolean canRun, CumulativeReport threadCumulativeReport) {
+        while (canRun.get()) {
+            long startTime = System.currentTimeMillis();
+            long effectiveTime = startTime + 50;
+
+            if (!globalPause) {
+                try {
+                    List<World> worldList = lastWorldList;
+                    List<PlayerChunkView> viewList = Arrays.asList(playersViewMap.values().toArray(new PlayerChunkView[0]));
+                    Collections.shuffle(viewList);
+                    for (PlayerChunkView view : viewList) {
+                        view.move();
+                    }
+                    Map<World, List<PlayerChunkView>> worldsViews = new HashMap<>();
+                    for (PlayerChunkView view : viewList) {
+                        worldsViews.computeIfAbsent(view.getLastWorld(), key -> new ArrayList<>()).add(view);
+                    }
+
+                    handleServer:
+                    {
+                        for (World world : worldList) {
+                            CraftWorld craftWorld = (CraftWorld) world;
+                            ZeroChunkWorldConfig configWorld = craftWorld.getHandle().fusionConfig.zeroChunkConfig;
+                            if (!configWorld.enable)
+                                continue;
+                            CumulativeReport worldCumulativeReport = worldsCumulativeReport.get(world);
+                            if (worldCumulativeReport == null)
+                                continue;
+                            NetworkTraffic worldNetworkTraffic = worldsNetworkTraffic.get(world);
+                            if (worldNetworkTraffic == null)
+                                continue;
+                            if (serverNetworkTraffic.exceed(FusionConfig.zeroChunkConfig.serverSendSecondMaxBytes / 20))
+                                break handleServer;
+                            if (worldNetworkTraffic.exceed(configWorld.worldSendSecondMaxBytes / 20))
+                                continue;
+
+                            AtomicInteger worldGeneratedChunk = worldsGeneratedChunk.getOrDefault(world, new AtomicInteger(Integer.MAX_VALUE));
+
+                            handleWorld:
+                            {
+                                boolean playersFull = false;
+                                while (!playersFull && effectiveTime >= System.currentTimeMillis()) {
+                                    playersFull = true;
+                                    for (PlayerChunkView view : worldsViews.getOrDefault(world, new ArrayList<>(0))) {
+                                        if (serverNetworkTraffic.exceed(FusionConfig.zeroChunkConfig.serverSendSecondMaxBytes / 20))
+                                            break handleServer;
+                                        if (worldNetworkTraffic.exceed(configWorld.worldSendSecondMaxBytes / 20))
+                                            break handleWorld;
+                                        synchronized (view.networkTraffic) {
+                                            Integer forciblySendSecondMaxBytes = view.forciblySendSecondMaxBytes;
+                                            if (view.networkTraffic.exceed(forciblySendSecondMaxBytes != null ? (int) (forciblySendSecondMaxBytes * FusionConfig.zeroChunkConfig.playerNetworkSpeedUseDegree) / 20 : configWorld.playerSendSecondMaxBytes / 20))
+                                                continue;
+                                            if (FusionConfig.zeroChunkConfig.autoAdaptPlayerNetworkSpeed && view.networkTraffic.exceed(Math.max(1, view.networkSpeed.avg() * 50)))
+                                                continue;
+                                        }
+                                        if (view.waitSend) {
+                                            playersFull = false;
+                                            continue;
+                                        }
+                                        if (view.moveTooFast)
+                                            continue;
+                                        view.waitSend = true;
+                                        long syncKey = view.syncKey;
+                                        Long chunkKey = view.next();
+                                        if (chunkKey == null) {
+                                            view.waitSend = false;
+                                            continue;
+                                        }
+                                        playersFull = false;
+                                        int chunkX = ViewMap.getX(chunkKey);
+                                        int chunkZ = ViewMap.getZ(chunkKey);
+
+                                        handlePlayer:
+                                        {
+                                            if (!FusionConfig.zeroChunkConfig.disableFastProcess) {
+                                                try {
+                                                    if (configWorld.readServerLoadedChunk) {
+                                                        Chunk chunk = branchMinecraft.getChunkFromMemoryCache(world, chunkX, chunkZ);
+                                                        if (chunk != null) {
+                                                            serverCumulativeReport.increaseLoadFast();
+                                                            worldCumulativeReport.increaseLoadFast();
+                                                            view.cumulativeReport.increaseLoadFast();
+                                                            threadCumulativeReport.increaseLoadFast();
+                                                            List<Runnable> asyncRunnable = new ArrayList<>();
+                                                            BranchChunkLight chunkLight = branchMinecraft.fromLight(world);
+                                                            BranchNBT chunkNBT = branchMinecraft.fromChunk(world, chunk).toNBT(chunkLight, asyncRunnable);
+                                                            asyncRunnable.forEach(Runnable::run);
+                                                            sendChunk(world, configWorld, worldNetworkTraffic, view, chunkX, chunkZ, chunkNBT, chunkLight, syncKey, worldCumulativeReport, threadCumulativeReport);
+                                                            break handlePlayer;
+                                                        }
+                                                    }
+                                                } catch (NullPointerException | NoClassDefFoundError | NoSuchMethodError | NoSuchFieldError exception) {
+                                                    exception.printStackTrace();
+                                                } catch (Exception ignored) {
+                                                }
+
+                                                try {
+                                                    BranchNBT chunkNBT = branchMinecraft.getChunkNBTFromDisk(world, chunkX, chunkZ);
+                                                    if (chunkNBT != null && branchMinecraft.fromStatus(chunkNBT).isAbove(BranchChunk.Status.FULL)) {
+                                                        serverCumulativeReport.increaseLoadFast();
+                                                        worldCumulativeReport.increaseLoadFast();
+                                                        view.cumulativeReport.increaseLoadFast();
+                                                        threadCumulativeReport.increaseLoadFast();
+                                                        sendChunk(world, configWorld, worldNetworkTraffic, view, chunkX, chunkZ, chunkNBT, branchMinecraft.fromLight(world, chunkNBT), syncKey, worldCumulativeReport, threadCumulativeReport);
+                                                        break handlePlayer;
+                                                    }
+                                                } catch (NullPointerException | NoClassDefFoundError | NoSuchMethodError | NoSuchFieldError exception) {
+                                                    exception.printStackTrace();
+                                                } catch (Exception ignored) {
+                                                }
+                                            }
+
+                                            boolean canGenerated = serverGeneratedChunk.get() < FusionConfig.zeroChunkConfig.serverTickMaxGenerateAmount && worldGeneratedChunk.get() < configWorld.worldTickMaxGenerateAmount;
+                                            if (canGenerated) {
+                                                serverGeneratedChunk.incrementAndGet();
+                                                worldGeneratedChunk.incrementAndGet();
+                                            }
+
+                                            try {
+                                                Chunk chunk = world.getChunkAtAsync(chunkX, chunkZ, canGenerated, true).get();
+                                                if (chunk != null) {
+                                                    serverCumulativeReport.increaseLoadSlow();
+                                                    worldCumulativeReport.increaseLoadSlow();
+                                                    view.cumulativeReport.increaseLoadSlow();
+                                                    threadCumulativeReport.increaseLoadSlow();
+                                                    try {
+                                                        List<Runnable> asyncRunnable = new ArrayList<>();
+                                                        BranchChunkLight chunkLight = branchMinecraft.fromLight(world);
+                                                        BranchNBT chunkNBT = branchMinecraft.fromChunk(world, chunk).toNBT(chunkLight, asyncRunnable);
+                                                        asyncRunnable.forEach(Runnable::run);
+                                                        sendChunk(world, configWorld, worldNetworkTraffic, view, chunkX, chunkZ, chunkNBT, chunkLight, syncKey, worldCumulativeReport, threadCumulativeReport);
+                                                        break handlePlayer;
+                                                    } catch (NullPointerException | NoClassDefFoundError | NoSuchMethodError | NoSuchFieldError exception) {
+                                                        exception.printStackTrace();
+                                                    } catch (Exception ignored) {
+                                                    }
+                                                } else if (FusionConfig.zeroChunkConfig.serverTickMaxGenerateAmount > 0 && configWorld.worldTickMaxGenerateAmount > 0) {
+                                                    view.remove(chunkX, chunkZ);
+                                                    break handlePlayer;
+                                                }
+                                            } catch (ExecutionException ignored) {
+                                                view.remove(chunkX, chunkZ);
+                                                break handlePlayer;
+                                            } catch (NoSuchMethodError methodError) {
+                                                if (canGenerated) {
+                                                    serverCumulativeReport.increaseLoadSlow();
+                                                    worldCumulativeReport.increaseLoadSlow();
+                                                    view.cumulativeReport.increaseLoadSlow();
+                                                    threadCumulativeReport.increaseLoadSlow();
+                                                    try {
+                                                        List<Runnable> asyncRunnable = new ArrayList<>();
+                                                        BranchChunkLight chunkLight = branchMinecraft.fromLight(world);
+                                                        CompletableFuture<BranchNBT> syncNBT = new CompletableFuture<>();
+                                                        waitMoveSyncQueue.add(() -> syncNBT.complete(branchMinecraft.fromChunk(world, world.getChunkAt(chunkX, chunkZ)).toNBT(chunkLight, asyncRunnable)));
+                                                        BranchNBT chunkNBT = syncNBT.get();
+                                                        asyncRunnable.forEach(Runnable::run);
+                                                        sendChunk(world, configWorld, worldNetworkTraffic, view, chunkX, chunkZ, chunkNBT, chunkLight, syncKey, worldCumulativeReport, threadCumulativeReport);
+                                                        break handlePlayer;
+                                                    } catch (NullPointerException | NoClassDefFoundError | NoSuchMethodError | NoSuchFieldError exception) {
+                                                        exception.printStackTrace();
+                                                    } catch (Exception ignored) {
+                                                    }
+                                                }
+                                            } catch (InterruptedException ignored) {
+                                            } catch (Exception ex) {
+                                                ex.printStackTrace();
+                                            }
+                                        }
+
+                                        view.waitSend = false;
+                                    }
+
+                                    try {
+                                        Thread.sleep(0L);
+                                    } catch (InterruptedException ignored) {
+                                    }
+                                }
+                            }
+                        }
+                    }
+                } catch (Exception exception) {
+                    exception.printStackTrace();
+                }
+            }
+
+            long endTime = System.currentTimeMillis();
+            long needSleep = 50 - (endTime - startTime);
+            if (needSleep > 0) {
+                try {
+                    Thread.sleep(needSleep);
+                } catch (InterruptedException ignored) {
+                }
+            }
+        }
+    }
+
+    private void sendChunk(World world, ZeroChunkWorldConfig configWorld, NetworkTraffic worldNetworkTraffic, PlayerChunkView view, int chunkX, int chunkZ, BranchNBT chunkNBT, BranchChunkLight chunkLight, long syncKey, CumulativeReport worldCumulativeReport, CumulativeReport threadCumulativeReport) {
+        BranchChunk chunk = branchMinecraft.fromChunk(world, chunkX, chunkZ, chunkNBT, FusionConfig.zeroChunkConfig.calculateMissingHeightMap);
+        PlayerSendExtendChunkEvent event = new PlayerSendExtendChunkEvent(view.viewAPI, chunk, world);
+        Bukkit.getPluginManager().callEvent(event);
+        if (event.isCancelled())
+            return;
+
+        if (configWorld.preventXray != null && configWorld.preventXray.size() > 0) {
+            for (Map.Entry<BlockData, BlockData[]> conversionMap : configWorld.preventXray.entrySet())
+                chunk.replaceAllMaterial(conversionMap.getValue(), conversionMap.getKey());
+        }
+
+        AtomicInteger consumeTraffic = new AtomicInteger(0);
+        Consumer<Player> chunkAndLightPacket = branchPacket.sendChunkAndLight(chunk.getChunk(), chunkLight, configWorld.sendTitleData, consumeTraffic::addAndGet);
+
+        synchronized (view.networkSpeed) {
+            Location nowLoc = view.getPlayer().getLocation();
+            int nowChunkX = nowLoc.getBlockX() >> 4;
+            int nowChunkZ = nowLoc.getBlockZ() >> 4;
+            ViewMap viewMap = view.getMap();
+            if (world != nowLoc.getWorld()) {
+                view.getMap().markWaitPosition(chunkX, chunkZ);
+                return;
+            }
+            if (view.getMap().isWaitPosition(chunkX, chunkZ))
+                return;
+            if (viewShape.isInsideEdge(nowChunkX, nowChunkZ, chunkX, chunkZ, viewMap.serverDistance))
+                return;
+            if (view.syncKey != syncKey)
+                return;
+            if (!running)
+                return;
+
+            boolean needMeasure = FusionConfig.zeroChunkConfig.autoAdaptPlayerNetworkSpeed && ((view.networkSpeed.speedID == null && view.networkSpeed.speedTimestamp + 1000 <= System.currentTimeMillis()) || view.networkSpeed.speedTimestamp + 30000 <= System.currentTimeMillis());
+            if (needMeasure) {
+                if (view.networkSpeed.speedID != null) {
+                    view.networkSpeed.add(30000, 0);
+                }
+                long pingID = random.nextLong();
+                view.networkSpeed.pingID = pingID;
+                view.networkSpeed.pingTimestamp = System.currentTimeMillis();
+                branchPacket.sendKeepAlive(view.getPlayer(), pingID);
+            }
+
+            chunkAndLightPacket.accept(view.getPlayer());
+            serverNetworkTraffic.use(consumeTraffic.get());
+            worldNetworkTraffic.use(consumeTraffic.get());
+            view.networkTraffic.use(consumeTraffic.get());
+            serverCumulativeReport.addConsume(consumeTraffic.get());
+            worldCumulativeReport.addConsume(consumeTraffic.get());
+            view.cumulativeReport.addConsume(consumeTraffic.get());
+            threadCumulativeReport.addConsume(consumeTraffic.get());
+
+            if (needMeasure) {
+                long speedID = random.nextLong();
+                view.networkSpeed.speedID = speedID;
+                view.networkSpeed.speedConsume = consumeTraffic.get();
+                view.networkSpeed.speedTimestamp = System.currentTimeMillis();
+                branchPacket.sendKeepAlive(view.getPlayer(), speedID);
+            }
+        }
+    }
+
+    public void packetEvent(Player player, PacketEvent event) {
+        PlayerChunkView view = getView(player);
+        if (view == null)
+            return;
+        if (event instanceof PacketMapChunkEvent) {
+            PacketMapChunkEvent chunkEvent = (PacketMapChunkEvent) event;
+            view.send(chunkEvent.getChunkX(), chunkEvent.getChunkZ());
+        }
+    }
+
+    public void respawnView(Player player) {
+        PlayerChunkView view = getView(player);
+        if (view == null)
+            return;
+        view.delay();
+        waitMoveSyncQueue.add(() -> branchPacket.sendViewDistance(player, view.getMap().extendDistance));
+    }
+
+    public void unloadView(Player player, Location from, Location move) {
+        PlayerChunkView view = getView(player);
+        if (view == null)
+            return;
+        int blockDistance = view.getMap().extendDistance << 4;
+        if (from.getWorld() != move.getWorld())
+            view.unload();
+        else if (Math.abs(from.getX() - move.getX()) >= blockDistance || Math.abs(from.getZ() - move.getZ()) >= blockDistance)
+            view.unload();
+    }
+
+    public void close() {
+        running = false;
+        for (BukkitTask task : bukkitTasks)
+            task.cancel();
+        multithreadedService.shutdown();
+    }
+
+    public final static ZeroChunk getInstance() {
+        return InnerInstanceClazz.instance;
+    }
+
+    private static class InnerInstanceClazz {
+        private static final ZeroChunk instance = new ZeroChunk();
+    }
+
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunk.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..241b67ab34845bed21552397ae76259d85639a50
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunk.java
@@ -0,0 +1,289 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import net.minecraft.core.Registry;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.*;
+import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.material.FluidState;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.block.data.CraftBlockData;
+import org.bukkit.util.Vector;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class BranchChunk {
+    private final ChunkAccess chunkAccess;
+    private final ServerLevel worldServer;
+
+
+    public BranchChunk(ServerLevel worldServer, ChunkAccess chunkAccess) {
+        this.chunkAccess = chunkAccess;
+        this.worldServer = worldServer;
+    }
+
+
+    public BranchNBT toNBT(BranchChunkLight light, List<Runnable> asyncRunnable) {
+        return new BranchNBT(BranchChunkRegionLoader.saveChunk(worldServer, chunkAccess, (BranchChunkLight) light, asyncRunnable));
+    }
+
+
+    public org.bukkit.Chunk getChunk() {
+        ChunkAccess chunk = chunkAccess;
+        if (chunk instanceof EmptyLevelChunk)
+            return ((LevelChunk) chunk).bukkitChunk;
+        else if (chunk instanceof LevelChunk)
+            return ((LevelChunk) chunk).bukkitChunk;
+        else if (chunk instanceof ProtoChunk)
+            return new LevelChunk(worldServer, ((ProtoChunk) chunk), v -> {
+            }).getBukkitChunk();
+        else
+            return null;
+    }
+
+    public org.bukkit.World getWorld() {
+        return worldServer.getWorld();
+    }
+
+
+    public BlockState getIBlockData(int x, int y, int z) {
+        int indexY = (y >> 4) - chunkAccess.getMinSection();
+        LevelChunkSection[] chunkSections = chunkAccess.getSections();
+        if (indexY >= 0 && indexY < chunkSections.length) {
+            LevelChunkSection chunkSection = chunkSections[indexY];
+            if (chunkSection != null && !chunkSection.hasOnlyAir())
+                return chunkSection.getBlockState(x & 15, y & 15, z & 15);
+        }
+        return Blocks.AIR.defaultBlockState();
+    }
+    public void setIBlockData(int x, int y, int z, BlockState iBlockData) {
+        int indexY = (y >> 4) - chunkAccess.getMinSection();
+        LevelChunkSection[] chunkSections = chunkAccess.getSections();
+        if (indexY >= 0 && indexY < chunkSections.length) {
+            LevelChunkSection chunkSection = chunkSections[indexY];
+            if (chunkSection == null)
+                chunkSection = chunkSections[indexY] = new LevelChunkSection(indexY, worldServer.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY));
+            chunkSection.setBlockState(x & 15, y & 15, z & 15, iBlockData, false);
+        }
+    }
+
+
+    public boolean equalsBlockData(int x, int y, int z, BlockData blockData) {
+        return equalsBlockData(x, y, z, ((CraftBlockData) blockData).getState());
+    }
+    public boolean equalsBlockData(int x, int y, int z, BlockState other) {
+        BlockState state = getIBlockData(x, y, z);
+        return state != null && state.equals(other);
+    }
+
+
+    public BlockData getBlockData(int x, int y, int z) {
+        BlockState blockData = getIBlockData(x, y, z);
+        return blockData != null ? CraftBlockData.fromData(blockData) : CraftBlockData.fromData(Blocks.AIR.defaultBlockState());
+    }
+
+
+    public void setBlockData(int x, int y, int z, BlockData blockData) {
+        BlockState iBlockData = ((CraftBlockData) blockData).getState();
+        if (iBlockData != null)
+            setIBlockData(x, y, z, iBlockData);
+    }
+
+
+    public Map<Vector, BlockData> getBlockDataMap() {
+        Map<Vector, BlockData> vectorBlockDataMap = new HashMap<>();
+        int maxHeight = worldServer.getMaxBuildHeight();
+        int minHeight = worldServer.getMinBuildHeight();
+        for (int x = 0; x < 16; x++) {
+            for (int y = minHeight; y < maxHeight; y++) {
+                for (int z = 0; z < 16; z++) {
+                    BlockData blockData = this.getBlockData(x, y, z);
+                    org.bukkit.Material material = blockData.getMaterial();
+                    if (material != org.bukkit.Material.AIR && material != org.bukkit.Material.VOID_AIR && material != org.bukkit.Material.CAVE_AIR) {
+                        vectorBlockDataMap.put(new Vector(x, y, z), blockData);
+                    }
+                }
+            }
+        }
+
+        return vectorBlockDataMap;
+    }
+
+
+    public int getX() {
+        return chunkAccess.getPos().x;
+    }
+
+    public int getZ() {
+        return chunkAccess.getPos().z;
+    }
+
+
+    private static Field field_LevelChunkSection_nonEmptyBlockCount;
+    static {
+        try {
+            field_LevelChunkSection_nonEmptyBlockCount = LevelChunkSection.class.getDeclaredField("f"); // TODO 映射 nonEmptyBlockCount
+            field_LevelChunkSection_nonEmptyBlockCount.setAccessible(true);
+        } catch (NoSuchFieldException exception) {
+            exception.printStackTrace();
+        }
+    }
+
+
+    public void replaceAllMaterial(BlockData[] target, BlockData to) {
+        Map<Block, BlockState> targetMap = new HashMap<>();
+        for (BlockData targetData : target) {
+            BlockState targetState = ((CraftBlockData) targetData).getState();
+            targetMap.put(targetState.getBlock(), targetState);
+        }
+        BlockState toI = ((CraftBlockData) to).getState();
+        for (LevelChunkSection section :chunkAccess.getSections()) {
+            if (section != null) {
+                AtomicInteger counts = new AtomicInteger();
+                PalettedContainer<BlockState> blocks = section.getStates();
+                List<Integer> conversionLocationList = new ArrayList<>();
+                PalettedContainer.CountConsumer<BlockState> forEachLocation = (state, location) -> {
+                    if (state == null)
+                        return;
+                    BlockState targetState = targetMap.get(state.getBlock());
+                    if (targetState != null) {
+                        conversionLocationList.add(location);
+                        state = toI;
+                    }
+                    if (!state.isAir())
+                        counts.incrementAndGet();
+                    FluidState fluid = state.getFluidState();
+                    if (!fluid.isEmpty())
+                        counts.incrementAndGet();
+                };
+                try {
+                    // 適用於 paper
+                    blocks.forEachLocation(forEachLocation);
+                } catch (NoSuchMethodError noSuchMethodError) {
+                    // 適用於 spigot (不推薦)
+                    blocks.count(forEachLocation);
+                }
+                conversionLocationList.forEach(location -> {
+                    blocks.getAndSetUnchecked(location & 15, location >> 8 & 15, location >> 4 & 15, toI);
+
+                });
+                try {
+                    field_LevelChunkSection_nonEmptyBlockCount.set(section, counts.shortValue());
+                } catch (IllegalAccessException exception) {
+                    exception.printStackTrace();
+                }
+            }
+        }
+    }
+
+
+    public org.bukkit.Material getMaterial(int x, int y, int z) {
+        return getBlockData(x, y, z).getMaterial();
+    }
+
+    public void setMaterial(int x, int y, int z, org.bukkit.Material material) {
+        setBlockData(x, y, z, material.createBlockData());
+    }
+
+
+    @Deprecated
+    public org.bukkit.block.Biome getBiome(int x, int z) {
+        return this.getBiome(x, 0, z);
+    }
+
+    public org.bukkit.block.Biome getBiome(int x, int y, int z) {
+        return CraftBlock.biomeBaseToBiome(chunkAccess.biomeRegistry, chunkAccess.getNoiseBiome(x, y, z));
+    }
+
+    @Deprecated
+    public void setBiome(int x, int z, org.bukkit.block.Biome biome) {
+        setBiome(x, 0, z, biome);
+    }
+    public void setBiome(int x, int y, int z, org.bukkit.block.Biome biome) {
+        chunkAccess.setBiome(x, y, z, CraftBlock.biomeToBiomeBase(chunkAccess.biomeRegistry, biome));
+    }
+
+    public boolean hasFluid(int x, int y, int z) {
+        return !getIBlockData(x, y, z).getFluidState().isEmpty();
+    }
+    public boolean isAir(int x, int y, int z) {
+        return getIBlockData(x, y, z).isAir();
+    }
+
+    public int getHighestY(int x, int z) {
+        return chunkAccess.getHeight(Heightmap.Types.MOTION_BLOCKING, x, z);
+    }
+
+
+    public static Status ofStatus(ChunkStatus chunkStatus) {
+        if (chunkStatus == ChunkStatus.EMPTY) {
+            return Status.EMPTY;
+        } else if (chunkStatus == ChunkStatus.STRUCTURE_STARTS) {
+            return Status.STRUCTURE_STARTS;
+        } else if (chunkStatus == ChunkStatus.STRUCTURE_REFERENCES) {
+            return Status.STRUCTURE_REFERENCES;
+        } else if (chunkStatus == ChunkStatus.BIOMES) {
+            return Status.BIOMES;
+        } else if (chunkStatus == ChunkStatus.NOISE) {
+            return Status.NOISE;
+        } else if (chunkStatus == ChunkStatus.SURFACE) {
+            return Status.SURFACE;
+        } else if (chunkStatus == ChunkStatus.CARVERS) {
+            return Status.CARVERS;
+        } else if (chunkStatus == ChunkStatus.LIQUID_CARVERS) {
+            return Status.LIQUID_CARVERS;
+        } else if (chunkStatus == ChunkStatus.FEATURES) {
+            return Status.FEATURES;
+        } else if (chunkStatus == ChunkStatus.LIGHT) {
+            return Status.LIGHT;
+        } else if (chunkStatus == ChunkStatus.SPAWN) {
+            return Status.SPAWN;
+        } else if (chunkStatus == ChunkStatus.HEIGHTMAPS) {
+            return Status.HEIGHTMAPS;
+        } else if (chunkStatus == ChunkStatus.FULL) {
+            return Status.FULL;
+        }
+        return Status.EMPTY;
+    }
+    public Status getStatus() {
+        return ofStatus(chunkAccess.getStatus());
+    }
+
+    public static enum Status {
+        EMPTY(0),
+        STRUCTURE_STARTS(1),
+        STRUCTURE_REFERENCES(2),
+        BIOMES(3),
+        NOISE(4),
+        SURFACE(5),
+        CARVERS(6),
+        LIQUID_CARVERS(7),
+        FEATURES(8),
+        LIGHT(9),
+        SPAWN(10),
+        HEIGHTMAPS(11),
+        FULL(12);
+
+        private final int sequence;
+
+        private Status(int sequence) {
+            this.sequence = sequence;
+        }
+
+        public boolean isAbove(Status status) {
+            return this.sequence >= status.sequence;
+        }
+
+        public boolean isUnder(Status status) {
+            return this.sequence <= status.sequence;
+        }
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunkLight.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunkLight.java
new file mode 100644
index 0000000000000000000000000000000000000000..711ff08ac382107dd7d21bf80812137e0520e8b7
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunkLight.java
@@ -0,0 +1,67 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+
+import java.util.Arrays;
+
+public final class BranchChunkLight {
+    public static final byte[] EMPTY = new byte[0];
+
+    private final ServerLevel worldServer;
+    private final byte[][] blockLights;
+    private final byte[][] skyLights;
+
+    public BranchChunkLight(World world) {
+        this(((CraftWorld) world).getHandle());
+    }
+
+    public BranchChunkLight(ServerLevel worldServer) {
+        this(worldServer, new byte[worldServer.getSectionsCount() + 2][], new byte[worldServer.getSectionsCount() + 2][]);
+    }
+
+    public BranchChunkLight(ServerLevel worldServer, byte[][] blockLights, byte[][] skyLights) {
+        this.worldServer = worldServer;
+        this.blockLights = blockLights;
+        this.skyLights = skyLights;
+        Arrays.fill(blockLights, EMPTY);
+        Arrays.fill(skyLights, EMPTY);
+    }
+
+    public ServerLevel getWorldServer() {
+        return worldServer;
+    }
+
+    public int getArrayLength() {
+        return blockLights.length;
+    }
+
+    public static int indexFromSectionY(ServerLevel worldServer, int sectionY) {
+        return sectionY - worldServer.getMinSection() + 1;
+    }
+
+    public void setBlockLight(int sectionY, byte[] blockLight) {
+        blockLights[indexFromSectionY(worldServer, sectionY)] = blockLight;
+    }
+
+    public void setSkyLight(int sectionY, byte[] skyLight) {
+        skyLights[indexFromSectionY(worldServer, sectionY)] = skyLight;
+    }
+
+    public byte[] getBlockLight(int sectionY) {
+        return blockLights[indexFromSectionY(worldServer, sectionY)];
+    }
+
+    public byte[] getSkyLight(int sectionY) {
+        return skyLights[indexFromSectionY(worldServer, sectionY)];
+    }
+
+    public byte[][] getBlockLights() {
+        return blockLights;
+    }
+
+    public byte[][] getSkyLights() {
+        return skyLights;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunkRegionLoader.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunkRegionLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..960e49077a5c021a4813229256ab13edad3733b9
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchChunkRegionLoader.java
@@ -0,0 +1,391 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.Dynamic;
+import it.unimi.dsi.fastutil.shorts.ShortList;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.core.SectionPos;
+import net.minecraft.nbt.*;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerChunkCache;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ThreadedLevelLightEngine;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.*;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import net.minecraft.world.level.levelgen.BelowZeroRetrogen;
+import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.levelgen.blending.BlendingData;
+import net.minecraft.world.level.lighting.LevelLightEngine;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.ticks.LevelChunkTicks;
+import net.minecraft.world.ticks.ProtoChunkTicks;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+public final class BranchChunkRegionLoader {
+    private static final int CURRENT_DATA_VERSION = SharedConstants.getCurrentVersion().getDataVersion().getVersion();
+    private static final boolean JUST_CORRUPT_IT = Boolean.getBoolean("Paper.ignoreWorldDataVersion");
+
+
+    public static BranchChunk.Status loadStatus(CompoundTag nbt) {
+        try {
+            // 適用於 paper
+            return BranchChunk.ofStatus(ChunkStatus.getStatus(nbt.getString("Status")));
+        } catch (NoSuchMethodError noSuchMethodError) {
+            // 適用於 spigot (不推薦)
+            return BranchChunk.ofStatus(ChunkStatus.byName(nbt.getString("Status")));
+        }
+    }
+
+    private static Codec<PalettedContainerRO<Holder<Biome>>> makeBiomeCodec(Registry<Biome> biomeRegistry) {
+        return PalettedContainer.codecRO(biomeRegistry.asHolderIdMap(), biomeRegistry.holderByNameCodec(), PalettedContainer.Strategy.SECTION_BIOMES, biomeRegistry.getHolderOrThrow(Biomes.PLAINS));
+    }
+
+
+    private static Method method_ChunkSerializer_makeBiomeCodecRW;
+
+    static {
+        try {
+            method_ChunkSerializer_makeBiomeCodecRW = ChunkSerializer.class.getDeclaredMethod("makeBiomeCodecRW", Registry.class);
+            method_ChunkSerializer_makeBiomeCodecRW.setAccessible(true);
+        } catch (NoSuchMethodException ex) {
+            ex.printStackTrace();
+        }
+
+    }
+
+    private static Codec<PalettedContainer<Holder<Biome>>> makeBiomeCodecRW(Registry<Biome> biomeRegistry) {
+        try {
+            return (Codec<PalettedContainer<Holder<Biome>>>) method_ChunkSerializer_makeBiomeCodecRW.invoke(null, biomeRegistry);
+        } catch (InvocationTargetException | IllegalAccessException ex) {
+            ex.printStackTrace();
+            return null;
+        }
+    }
+
+
+    public static BranchChunk loadChunk(ServerLevel world, int chunkX, int chunkZ, CompoundTag nbt, boolean integralHeightmap) {
+        if (nbt.contains("DataVersion", 99)) {
+            int dataVersion = nbt.getInt("DataVersion");
+            if (!JUST_CORRUPT_IT && dataVersion > CURRENT_DATA_VERSION) {
+                (new RuntimeException("Server attempted to load chunk saved with newer version of minecraft! " + dataVersion + " > " + CURRENT_DATA_VERSION)).printStackTrace();
+                System.exit(1);
+            }
+        }
+
+        ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
+        UpgradeData upgradeData = nbt.contains("UpgradeData", 10) ? new UpgradeData(nbt.getCompound("UpgradeData"), world) : UpgradeData.EMPTY;
+        boolean isLightOn = Objects.requireNonNullElse(ChunkStatus.byName(nbt.getString("Status")), ChunkStatus.EMPTY).isOrAfter(ChunkStatus.LIGHT) && (nbt.get("isLightOn") != null || nbt.getInt("starlight.light_version") == 6);
+        ListTag sectionArrayNBT = nbt.getList("sections", 10);
+        int sectionsCount = world.getSectionsCount();
+        LevelChunkSection[] sections = new LevelChunkSection[sectionsCount];
+        ServerChunkCache chunkSource = world.getChunkSource();
+        LevelLightEngine lightEngine = chunkSource.getLightEngine();
+        Registry<Biome> biomeRegistry = world.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY);
+        Codec<PalettedContainer<Holder<Biome>>> paletteCodec = makeBiomeCodecRW(biomeRegistry);
+        for (int sectionIndex = 0; sectionIndex < sectionArrayNBT.size(); ++sectionIndex) {
+            CompoundTag sectionNBT = sectionArrayNBT.getCompound(sectionIndex);
+            byte locationY = sectionNBT.getByte("Y");
+            int sectionY = world.getSectionIndexFromSectionY(locationY);
+            if (sectionY >= 0 && sectionY < sections.length) {
+                // 方塊轉換器
+                PalettedContainer<BlockState> paletteBlock;
+                if (sectionNBT.contains("block_states", 10)) {
+                    paletteBlock = ChunkSerializer.BLOCK_STATE_CODEC.parse(NbtOps.INSTANCE, sectionNBT.getCompound("block_states")).promotePartial((sx) -> {
+                    }).getOrThrow(false, (message) -> {
+                    });
+                } else {
+                    paletteBlock = new PalettedContainer<>(Block.BLOCK_STATE_REGISTRY, Blocks.AIR.defaultBlockState(), PalettedContainer.Strategy.SECTION_STATES);
+                }
+
+                // 生態轉換器
+                PalettedContainer<Holder<Biome>> paletteBiome;
+                if (sectionNBT.contains("biomes", 10)) {
+                    paletteBiome = paletteCodec.parse(NbtOps.INSTANCE, sectionNBT.getCompound("biomes")).promotePartial((sx) -> {
+                    }).getOrThrow(false, (message) -> {
+                    });
+                } else {
+                    try {
+                        // 適用於 paper
+                        paletteBiome = new PalettedContainer<>(biomeRegistry.asHolderIdMap(), biomeRegistry.getHolderOrThrow(Biomes.PLAINS), PalettedContainer.Strategy.SECTION_BIOMES, null);
+                    } catch (NoSuchMethodError noSuchMethodError) {
+                        // 適用於 spigot (不推薦)
+                        paletteBiome = new PalettedContainer<>(biomeRegistry.asHolderIdMap(), biomeRegistry.getHolderOrThrow(Biomes.PLAINS), PalettedContainer.Strategy.SECTION_BIOMES);
+                    }
+                }
+
+                LevelChunkSection chunkSection = new LevelChunkSection(locationY, paletteBlock, paletteBiome);
+                sections[sectionY] = chunkSection;
+            }
+        }
+
+        long inhabitedTime = nbt.getLong("InhabitedTime");
+        ChunkStatus.ChunkType chunkType = ChunkSerializer.getChunkTypeFromTag(nbt);
+        BlendingData blendingData;
+        if (nbt.contains("blending_data", 10)) {
+            blendingData = BlendingData.CODEC.parse(new Dynamic<>(NbtOps.INSTANCE, nbt.getCompound("blending_data"))).resultOrPartial((sx) -> {
+            }).orElse(null);
+        } else {
+            blendingData = null;
+        }
+
+        ChunkAccess chunk;
+        if (chunkType == ChunkStatus.ChunkType.LEVELCHUNK) {
+            LevelChunkTicks<Block> ticksBlock = LevelChunkTicks.load(nbt.getList("block_ticks", 10), (sx) -> Registry.BLOCK.getOptional(ResourceLocation.tryParse(sx)), chunkPos);
+            LevelChunkTicks<Fluid> ticksFluid = LevelChunkTicks.load(nbt.getList("fluid_ticks", 10), (sx) -> Registry.FLUID.getOptional(ResourceLocation.tryParse(sx)), chunkPos);
+            LevelChunk levelChunk = new LevelChunk(world.getLevel(), chunkPos, upgradeData, ticksBlock, ticksFluid, inhabitedTime, sections, null, blendingData);
+            chunk = levelChunk;
+
+            // 實體方塊
+            ListTag blockEntities = nbt.getList("block_entities", 10);
+            for (int entityIndex = 0; entityIndex < blockEntities.size(); ++entityIndex) {
+                CompoundTag entityNBT = blockEntities.getCompound(entityIndex);
+                boolean keepPacked = entityNBT.getBoolean("keepPacked");
+                if (keepPacked) {
+                    chunk.setBlockEntityNbt(entityNBT);
+                } else {
+                    BlockPos blockPos = BlockEntity.getPosFromTag(entityNBT);
+                    BlockEntity blockEntity = BlockEntity.loadStatic(blockPos, chunk.getBlockState(blockPos), entityNBT);
+                    if (blockEntity != null) {
+                        levelChunk.getBlockEntities().put(blockPos, blockEntity);
+                    }
+                }
+            }
+        } else {
+            ProtoChunkTicks<Block> ticksBlock = ProtoChunkTicks.load(nbt.getList("block_ticks", 10), (sx) -> Registry.BLOCK.getOptional(ResourceLocation.tryParse(sx)), chunkPos);
+            ProtoChunkTicks<Fluid> ticksFluid = ProtoChunkTicks.load(nbt.getList("fluid_ticks", 10), (sx) -> Registry.FLUID.getOptional(ResourceLocation.tryParse(sx)), chunkPos);
+            ProtoChunk protochunk = new ProtoChunk(chunkPos, upgradeData, sections, ticksBlock, ticksFluid, world, biomeRegistry, blendingData);
+            chunk = protochunk;
+            protochunk.setInhabitedTime(inhabitedTime);
+            if (nbt.contains("below_zero_retrogen", 10)) {
+                BelowZeroRetrogen.CODEC.parse(new Dynamic<>(NbtOps.INSTANCE, nbt.getCompound("below_zero_retrogen"))).resultOrPartial((sx) -> {
+                }).ifPresent(protochunk::setBelowZeroRetrogen);
+            }
+
+            ChunkStatus chunkStatus = ChunkStatus.byName(nbt.getString("Status"));
+            protochunk.setStatus(chunkStatus);
+            if (chunkStatus.isOrAfter(ChunkStatus.FEATURES)) {
+                protochunk.setLightEngine(lightEngine);
+            }
+        }
+        chunk.setLightCorrect(isLightOn);
+
+        // 高度圖
+        CompoundTag heightmapsNBT = nbt.getCompound("Heightmaps");
+        EnumSet<Heightmap.Types> enumHeightmapType = EnumSet.noneOf(Heightmap.Types.class);
+        for (Heightmap.Types heightmapTypes : chunk.getStatus().heightmapsAfter()) {
+            String serializationKey = heightmapTypes.getSerializationKey();
+            if (heightmapsNBT.contains(serializationKey, 12)) {
+                chunk.setHeightmap(heightmapTypes, heightmapsNBT.getLongArray(serializationKey));
+            } else {
+                enumHeightmapType.add(heightmapTypes);
+            }
+        }
+        if (integralHeightmap) {
+            Heightmap.primeHeightmaps(chunk, enumHeightmapType);
+        }
+
+        ListTag processListNBT = nbt.getList("PostProcessing", 9);
+        for (int indexList = 0; indexList < processListNBT.size(); ++indexList) {
+            ListTag processNBT = processListNBT.getList(indexList);
+            for (int index = 0; index < processNBT.size(); ++index) {
+                chunk.addPackedPostProcess(processNBT.getShort(index), indexList);
+            }
+        }
+
+        if (chunkType == ChunkStatus.ChunkType.LEVELCHUNK) {
+            return new BranchChunk(world, chunk);
+        } else {
+            ProtoChunk protoChunk = (ProtoChunk) chunk;
+            return new BranchChunk(world, protoChunk);
+        }
+    }
+
+    public static BranchChunkLight loadLight(ServerLevel world, CompoundTag nbt) {
+        // 檢查資料版本
+        if (nbt.contains("DataVersion", 99)) {
+            int dataVersion = nbt.getInt("DataVersion");
+            if (!JUST_CORRUPT_IT && dataVersion > CURRENT_DATA_VERSION) {
+                (new RuntimeException("Server attempted to load chunk saved with newer version of minecraft! " + dataVersion + " > " + CURRENT_DATA_VERSION)).printStackTrace();
+                System.exit(1);
+            }
+        }
+
+        boolean isLightOn = Objects.requireNonNullElse(ChunkStatus.byName(nbt.getString("Status")), ChunkStatus.EMPTY).isOrAfter(ChunkStatus.LIGHT) && (nbt.get("isLightOn") != null || nbt.getInt("starlight.light_version") == 6);
+        boolean hasSkyLight = world.dimensionType().hasSkyLight();
+        ListTag sectionArrayNBT = nbt.getList("sections", 10);
+        BranchChunkLight chunkLight = new BranchChunkLight(world);
+        for (int sectionIndex = 0; sectionIndex < sectionArrayNBT.size(); ++sectionIndex) {
+            CompoundTag sectionNBT = sectionArrayNBT.getCompound(sectionIndex);
+            byte locationY = sectionNBT.getByte("Y");
+            if (isLightOn) {
+                if (sectionNBT.contains("BlockLight", 7)) {
+                    chunkLight.setBlockLight(locationY, sectionNBT.getByteArray("BlockLight"));
+                }
+                if (hasSkyLight) {
+                    if (sectionNBT.contains("SkyLight", 7)) {
+                        chunkLight.setSkyLight(locationY, sectionNBT.getByteArray("SkyLight"));
+                    }
+                }
+            }
+        }
+
+        return chunkLight;
+    }
+
+
+    public static CompoundTag saveChunk(ServerLevel world, ChunkAccess chunk, BranchChunkLight light, List<Runnable> asyncRunnable) {
+        int minSection = world.getMinSection() - 1;//WorldUtil.getMinLightSection();
+        ChunkPos chunkPos = chunk.getPos();
+        CompoundTag nbt = new CompoundTag();
+        nbt.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
+        nbt.putInt("xPos", chunkPos.x);
+        nbt.putInt("yPos", chunk.getMinSection());
+        nbt.putInt("zPos", chunkPos.z);
+        nbt.putLong("LastUpdate", world.getGameTime());
+        nbt.putLong("InhabitedTime", chunk.getInhabitedTime());
+        nbt.putString("Status", chunk.getStatus().getName());
+        BlendingData blendingData = chunk.getBlendingData();
+        if (blendingData != null) {
+            BlendingData.CODEC.encodeStart(NbtOps.INSTANCE, blendingData).resultOrPartial((sx) -> {
+            }).ifPresent((nbtData) -> nbt.put("blending_data", nbtData));
+        }
+
+        BelowZeroRetrogen belowZeroRetrogen = chunk.getBelowZeroRetrogen();
+        if (belowZeroRetrogen != null) {
+            BelowZeroRetrogen.CODEC.encodeStart(NbtOps.INSTANCE, belowZeroRetrogen).resultOrPartial((sx) -> {
+            }).ifPresent((nbtData) -> nbt.put("below_zero_retrogen", nbtData));
+        }
+
+        LevelChunkSection[] chunkSections = chunk.getSections();
+        ListTag sectionArrayNBT = new ListTag();
+        ThreadedLevelLightEngine lightEngine = world.getChunkSource().getLightEngine();
+
+        // 生態解析器
+        Registry<Biome> biomeRegistry = world.registryAccess().registryOrThrow(Registry.BIOME_REGISTRY);
+        Codec<PalettedContainerRO<Holder<Biome>>> paletteCodec = makeBiomeCodec(biomeRegistry);
+        boolean lightCorrect = false;
+
+        for (int locationY = lightEngine.getMinLightSection(); locationY < lightEngine.getMaxLightSection(); ++locationY) {
+            int sectionY = chunk.getSectionIndexFromSectionY(locationY);
+            boolean inSections = sectionY >= 0 && sectionY < chunkSections.length;
+            ThreadedLevelLightEngine lightEngineThreaded = world.getChunkSource().getLightEngine();
+            DataLayer blockNibble;
+            DataLayer skyNibble;
+            try {
+                // 適用於 paper
+                blockNibble = chunk.getBlockNibbles()[locationY - minSection].toVanillaNibble();
+                skyNibble = chunk.getSkyNibbles()[locationY - minSection].toVanillaNibble();
+            } catch (NoSuchMethodError noSuchMethodError) {
+                // 適用於 spigot (不推薦)
+                blockNibble = lightEngineThreaded.getLayerListener(LightLayer.BLOCK).getDataLayerData(SectionPos.of(chunkPos, locationY));
+                skyNibble = lightEngineThreaded.getLayerListener(LightLayer.SKY).getDataLayerData(SectionPos.of(chunkPos, locationY));
+            }
+
+            if (inSections || blockNibble != null || skyNibble != null) {
+                CompoundTag sectionNBT = new CompoundTag();
+                if (inSections) {
+                    LevelChunkSection chunkSection = chunkSections[sectionY];
+                    asyncRunnable.add(() -> {
+                        sectionNBT.put("block_states", ChunkSerializer.BLOCK_STATE_CODEC.encodeStart(NbtOps.INSTANCE, chunkSection.getStates()).getOrThrow(false, (message) -> {
+                        }));
+                        sectionNBT.put("biomes", paletteCodec.encodeStart(NbtOps.INSTANCE, chunkSection.getBiomes()).getOrThrow(false, (message) -> {
+                        }));
+                    });
+                }
+
+                if (blockNibble != null) {
+                    if (!blockNibble.isEmpty()) {
+                        if (light != null) {
+                            light.setBlockLight(locationY, blockNibble.getData());
+                        } else {
+                            sectionNBT.putByteArray("BlockLight", blockNibble.getData());
+                            lightCorrect = true;
+                        }
+                    }
+                }
+
+                if (skyNibble != null) {
+                    if (!skyNibble.isEmpty()) {
+                        if (light != null) {
+                            light.setSkyLight(locationY, skyNibble.getData());
+                        } else {
+                            sectionNBT.putByteArray("SkyLight", skyNibble.getData());
+                            lightCorrect = true;
+                        }
+                    }
+                }
+
+                // 增加 inSections 確保 asyncRunnable 不會出資料錯誤
+                if (!sectionNBT.isEmpty() || inSections) {
+                    sectionNBT.putByte("Y", (byte) locationY);
+                    sectionArrayNBT.add(sectionNBT);
+                }
+            }
+        }
+        nbt.put("sections", sectionArrayNBT);
+
+        if (lightCorrect) {
+            nbt.putInt("starlight.light_version", 6);
+            nbt.putBoolean("isLightOn", true);
+        }
+
+        // 實體方塊
+        ListTag blockEntitiesNBT = new ListTag();
+        for (BlockPos blockPos : chunk.getBlockEntitiesPos()) {
+            CompoundTag blockEntity = chunk.getBlockEntityNbtForSaving(blockPos);
+            if (blockEntity != null) {
+                blockEntitiesNBT.add(blockEntity);
+            }
+        }
+        nbt.put("block_entities", blockEntitiesNBT);
+
+        if (chunk.getStatus().getChunkType() == ChunkStatus.ChunkType.PROTOCHUNK) {
+        }
+
+        ChunkAccess.TicksToSave tickSchedulers = chunk.getTicksForSerialization();
+        long gameTime = world.getLevelData().getGameTime();
+        nbt.put("block_ticks", tickSchedulers.blocks().save(gameTime, (block) -> Registry.BLOCK.getKey(block).toString()));
+        nbt.put("fluid_ticks", tickSchedulers.fluids().save(gameTime, (fluid) -> Registry.FLUID.getKey(fluid).toString()));
+
+        ShortList[] packOffsetList = chunk.getPostProcessing();
+        ListTag packOffsetsNBT = new ListTag();
+        for (ShortList shortlist : packOffsetList) {
+            ListTag packsNBT = new ListTag();
+            if (shortlist != null) {
+                for (Short shortData : shortlist) {
+                    packsNBT.add(ShortTag.valueOf(shortData));
+                }
+            }
+            packOffsetsNBT.add(packsNBT);
+        }
+        nbt.put("PostProcessing", packOffsetsNBT);
+
+        // 高度圖
+        CompoundTag heightmapsNBT = new CompoundTag();
+        for (Map.Entry<Heightmap.Types, Heightmap> entry : chunk.getHeightmaps()) {
+            if (chunk.getStatus().heightmapsAfter().contains(entry.getKey())) {
+                heightmapsNBT.put(entry.getKey().getSerializationKey(), new LongArrayTag(entry.getValue().getRawData()));
+            }
+        }
+        nbt.put("Heightmaps", heightmapsNBT);
+
+        return nbt;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchMinecraft.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchMinecraft.java
new file mode 100644
index 0000000000000000000000000000000000000000..410a2bd7a48511568bc37229fc4889ebc3534762
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchMinecraft.java
@@ -0,0 +1,99 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import io.netty.channel.*;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.EmptyLevelChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+
+import java.io.IOException;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+
+public final class BranchMinecraft {
+
+    public BranchNBT getChunkNBTFromDisk(World world, int chunkX, int chunkZ) throws IOException {
+        CompoundTag nbt = null;
+        try {
+            CompletableFuture<Optional<CompoundTag>> futureNBT = ((CraftWorld) world).getHandle().getChunkSource().chunkMap.read(new ChunkPos(chunkX, chunkZ));
+            Optional<CompoundTag> optionalNBT = futureNBT.get();
+            nbt = optionalNBT.orElse(null);
+        } catch (InterruptedException | ExecutionException ignored) {
+        }
+        return nbt != null ? new BranchNBT(nbt) : null;
+    }
+
+    public org.bukkit.Chunk getChunkFromMemoryCache(World world, int chunkX, int chunkZ) {
+        try {
+            // 適用於 paper
+            ChunkHolder playerChunk = ((CraftWorld) world).getHandle().getChunkSource().chunkMap.getVisibleChunkIfPresent((long) chunkZ << 32 | (long) chunkX & 4294967295L);
+            if (playerChunk != null) {
+                ChunkAccess chunk = playerChunk.getAvailableChunkNow();
+                if (chunk != null && !(chunk instanceof EmptyLevelChunk) && chunk instanceof LevelChunk) {
+                    LevelChunk levelChunk = (LevelChunk) chunk;
+                    return levelChunk.bukkitChunk;
+                }
+            }
+            return null;
+        } catch (NoSuchMethodError ignored) {
+            return null;
+        }
+    }
+
+    public BranchChunk fromChunk(World world, int chunkX, int chunkZ, BranchNBT nbt, boolean integralHeightmap) {
+        return BranchChunkRegionLoader.loadChunk(((CraftWorld) world).getHandle(), chunkX, chunkZ, ((BranchNBT) nbt).getNMSTag(), integralHeightmap);
+    }
+
+    public BranchChunkLight fromLight(World world, BranchNBT nbt) {
+        return BranchChunkRegionLoader.loadLight(((CraftWorld) world).getHandle(), ((BranchNBT) nbt).getNMSTag());
+    }
+
+    public BranchChunkLight fromLight(World world) {
+        return new BranchChunkLight(((CraftWorld) world).getHandle());
+    }
+
+    public BranchChunk.Status fromStatus(BranchNBT nbt) {
+        return BranchChunkRegionLoader.loadStatus(((BranchNBT) nbt).getNMSTag());
+    }
+
+    public BranchChunk fromChunk(World world, org.bukkit.Chunk chunk) {
+        return new BranchChunk(((CraftChunk) chunk).getCraftWorld().getHandle(), ((CraftChunk) chunk).getHandle());
+    }
+
+    public void injectPlayer(ServerPlayer entityPlayer) {
+        ServerGamePacketListenerImpl connection = entityPlayer.connection;
+        Channel channel = connection.connection.channel;
+        ChannelPipeline pipeline = channel.pipeline();
+        pipeline.addAfter("packet_handler", "farther_view_distance_write", new ChannelDuplexHandler() {
+            @Override
+            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+                if (msg instanceof Packet) {
+                    if (!BranchProxyPlayerConnection.write(entityPlayer.getBukkitEntity(), (Packet<?>) msg))
+                        return;
+                }
+                super.write(ctx, msg, promise);
+            }
+        });
+        pipeline.addAfter("encoder", "farther_view_distance_read", new ChannelInboundHandlerAdapter() {
+            @Override
+            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+                if (msg instanceof Packet) {
+                    if (!BranchProxyPlayerConnection.read(entityPlayer.getBukkitEntity(), (Packet<?>) msg))
+                        return;
+                }
+                super.channelRead(ctx, msg);
+            }
+        });
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchNBT.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchNBT.java
new file mode 100644
index 0000000000000000000000000000000000000000..50988f7c3db4d5de8bb8bf0e5e7e05accd325763
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchNBT.java
@@ -0,0 +1,26 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import net.minecraft.nbt.CompoundTag;
+
+public final class BranchNBT {
+
+    protected CompoundTag tag;
+
+    public BranchNBT() {
+        this.tag = new CompoundTag();
+    }
+
+    public BranchNBT(CompoundTag tag) {
+        this.tag = tag;
+    }
+
+
+    public CompoundTag getNMSTag() {
+        return tag;
+    }
+
+    @Override
+    public String toString() {
+        return tag.toString();
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacket.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..c88489e4ba73858dfcb70b280f562e6f8b490c2d
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacket.java
@@ -0,0 +1,56 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.Connection;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
+import net.minecraft.network.protocol.game.ClientboundKeepAlivePacket;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ClientboundSetChunkCacheRadiusPacket;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+
+import java.util.function.Consumer;
+
+public final class BranchPacket {
+    private final BranchPacketHandleChunk handleChunk = new BranchPacketHandleChunk();
+    private final BranchPacketHandleLightUpdate handleLightUpdate = new BranchPacketHandleLightUpdate();
+
+    public void sendPacket(Player player, Packet<?> packet) {
+        try {
+            Connection container = ((CraftPlayer) player).getHandle().connection.connection;
+            container.send(packet);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    public void sendViewDistance(Player player, int viewDistance) {
+        sendPacket(player, new ClientboundSetChunkCacheRadiusPacket(viewDistance));
+    }
+
+    public void sendUnloadChunk(Player player, int chunkX, int chunkZ) {
+        sendPacket(player, new ClientboundForgetLevelChunkPacket(chunkX, chunkZ));
+    }
+
+    public Consumer<Player> sendChunkAndLight(org.bukkit.Chunk chunk, BranchChunkLight light, boolean needTile, Consumer<Integer> consumeTraffic) {
+        FriendlyByteBuf serializer = new FriendlyByteBuf(Unpooled.buffer().writerIndex(0));
+        serializer.writeInt(chunk.getX());
+        serializer.writeInt(chunk.getZ());
+        this.handleChunk.write(serializer, chunk, needTile);
+        this.handleLightUpdate.write(serializer, (BranchChunkLight) light, true);
+        consumeTraffic.accept(serializer.readableBytes());
+        ClientboundLevelChunkWithLightPacket packet = new ClientboundLevelChunkWithLightPacket(serializer);
+        try {
+            // 適用於 paper
+            packet.setReady(true);
+        } catch (NoSuchMethodError noSuchMethodError) {
+            // 適用於 spigot (不推薦)
+        }
+        return (player) -> sendPacket(player, packet);
+    }
+
+    public void sendKeepAlive(Player player, long id) {
+        sendPacket(player, new ClientboundKeepAlivePacket(id));
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacketHandleChunk.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacketHandleChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..e976ce6e8202b33f2476ef567a7f0215764026e6
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacketHandleChunk.java
@@ -0,0 +1,64 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
+import net.minecraft.core.SectionPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.LongArrayTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.levelgen.Heightmap;
+import org.bukkit.Chunk;
+import org.bukkit.craftbukkit.CraftChunk;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public final class BranchPacketHandleChunk {
+    public BranchPacketHandleChunk() {
+    }
+
+    public void write(FriendlyByteBuf serializer, Chunk chunk, boolean needTile) {
+        this.write(serializer, ((CraftChunk) chunk).getHandle(), needTile);
+    }
+
+    public void write(FriendlyByteBuf serializer, LevelChunk chunk, boolean needTile) {
+        CompoundTag heightmapsNBT = new CompoundTag();
+        for (Map.Entry<Heightmap.Types, Heightmap> entry : chunk.getHeightmaps()) {
+            Heightmap.Types heightType = entry.getKey();
+            Heightmap heightMap = entry.getValue();
+            if (heightType.sendToClient())
+                heightmapsNBT.put(heightType.getSerializationKey(), new LongArrayTag(heightMap.getRawData()));
+        }
+
+        int chunkSize = 0;
+        for (LevelChunkSection section : chunk.getSections()) {
+            chunkSize += section.getSerializedSize();
+        }
+        byte[] bufferBytes = new byte[chunkSize];
+        FriendlyByteBuf bufferByteBuf = new FriendlyByteBuf(Unpooled.wrappedBuffer(bufferBytes));
+        bufferByteBuf.writerIndex(0);
+        for (LevelChunkSection section : chunk.getSections()) {
+            section.write(bufferByteBuf);
+        }
+
+        serializer.writeNbt(heightmapsNBT);
+        serializer.writeVarInt(bufferBytes.length);
+        serializer.writeBytes(bufferBytes);
+
+        Map<BlockPos, BlockEntity> blockEntityMap = !needTile ? new HashMap<>(0) : chunk.getBlockEntities();
+        serializer.writeCollection(blockEntityMap.entrySet(), (buf, entry) -> {
+            BlockEntity blockEntity = entry.getValue();
+            //CompoundTag entityNBT = blockEntity.aa_();
+            CompoundTag entityNBT = blockEntity.getUpdateTag();
+            BlockPos blockPos = blockEntity.getBlockPos();
+            buf.writeByte(SectionPos.sectionRelative(blockPos.getX()) << 4 | SectionPos.sectionRelative(blockPos.getZ()));
+            buf.writeShort(blockPos.getY());
+            buf.writeVarInt(Registry.BLOCK_ENTITY_TYPE.getId(blockEntity.getType()));
+            buf.writeNbt(entityNBT.isEmpty() ? null : entityNBT);
+        });
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacketHandleLightUpdate.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacketHandleLightUpdate.java
new file mode 100644
index 0000000000000000000000000000000000000000..378c7c58546bc2b132e5832ca97e7bea9bb826fb
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchPacketHandleLightUpdate.java
@@ -0,0 +1,46 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import net.minecraft.network.FriendlyByteBuf;
+
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.List;
+
+public final class BranchPacketHandleLightUpdate {
+    public BranchPacketHandleLightUpdate() {
+    }
+
+    public void write(FriendlyByteBuf serializer, BranchChunkLight light, boolean trustEdges) {
+        List<byte[]> dataSky = new ArrayList<>();
+        List<byte[]> dataBlock = new ArrayList<>();
+        BitSet notSkyEmpty = new BitSet();
+        BitSet notBlockEmpty = new BitSet();
+        BitSet isSkyEmpty = new BitSet();
+        BitSet isBlockEmpty = new BitSet();
+
+        for (int index = 0; index < light.getArrayLength(); ++index) {
+            saveBitSet(light.getSkyLights(), index, notSkyEmpty, isSkyEmpty, dataSky);
+            saveBitSet(light.getBlockLights(), index, notBlockEmpty, isBlockEmpty, dataBlock);
+        }
+
+        serializer.writeBoolean(trustEdges);
+        serializer.writeBitSet(notSkyEmpty);
+        serializer.writeBitSet(notBlockEmpty);
+        serializer.writeBitSet(isSkyEmpty);
+        serializer.writeBitSet(isBlockEmpty);
+        serializer.writeCollection(dataSky, FriendlyByteBuf::writeByteArray);
+        serializer.writeCollection(dataBlock, FriendlyByteBuf::writeByteArray);
+    }
+
+    private static void saveBitSet(byte[][] nibbleArrays, int index, BitSet notEmpty, BitSet isEmpty, List<byte[]> list) {
+        byte[] nibbleArray = nibbleArrays[index];
+        if (nibbleArray != BranchChunkLight.EMPTY) {
+            if (nibbleArray == null) {
+                isEmpty.set(index);
+            } else {
+                notEmpty.set(index);
+                list.add(nibbleArray);
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchProxyPlayerConnection.java b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchProxyPlayerConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..c172c8854ebf5bff3dab998c366df7774d12edc1
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/branch/BranchProxyPlayerConnection.java
@@ -0,0 +1,98 @@
+package com.github.ipecter.fusion.zerochunk.branch;
+
+import com.github.ipecter.fusion.zerochunk.ZeroChunk;
+import com.github.ipecter.fusion.zerochunk.data.PlayerChunkView;
+import com.github.ipecter.fusion.zerochunk.event.packet.PacketKeepAliveEvent;
+import com.github.ipecter.fusion.zerochunk.event.packet.PacketMapChunkEvent;
+import com.github.ipecter.fusion.zerochunk.event.packet.PacketUnloadChunkEvent;
+import com.github.ipecter.fusion.zerochunk.event.packet.PacketViewDistanceEvent;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ClientboundSetChunkCacheRadiusPacket;
+import net.minecraft.network.protocol.game.ServerboundKeepAlivePacket;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+
+import java.lang.reflect.Field;
+
+public final class BranchProxyPlayerConnection {
+    public static boolean read(Player player, Packet<?> packet) {
+        if (packet instanceof ServerboundKeepAlivePacket) {
+            PacketKeepAliveEvent event = new PacketKeepAliveEvent(player, ((ServerboundKeepAlivePacket) packet).getId());
+            Bukkit.getPluginManager().callEvent(event);
+            long id = event.getId();
+            PlayerChunkView view = ZeroChunk.getInstance().getView(event.getPlayer());
+            if (view != null) {
+                synchronized (view.networkSpeed) {
+                    if (view.networkSpeed.pingID != null && view.networkSpeed.pingID == id) {
+                        view.networkSpeed.lastPing = Math.max(1, (int) (System.currentTimeMillis() - view.networkSpeed.pingTimestamp));
+                        view.networkSpeed.pingID = null;
+                        return true;
+                    } else if (view.networkSpeed.speedID != null && view.networkSpeed.speedID == id) {
+                        view.networkSpeed.add(Math.max(1, (int) (System.currentTimeMillis() - view.networkSpeed.speedTimestamp) - view.networkSpeed.lastPing), view.networkSpeed.speedConsume);
+                        view.networkSpeed.speedConsume = 0;
+                        view.networkSpeed.speedID = null;
+                        return true;
+                    }
+                }
+            }
+            return !event.isCancelled();
+        } else {
+            return true;
+        }
+    }
+
+
+    private static Field field_PacketPlayOutUnloadChunk_chunkX;
+    private static Field field_PacketPlayOutUnloadChunk_chunkZ;
+    private static Field field_PacketPlayOutViewDistance_distance;
+    private static Field field_ClientboundLevelChunkWithLightPacket_chunkX;
+    private static Field field_ClientboundLevelChunkWithLightPacket_chunkZ;
+
+    static {
+        try {
+            field_PacketPlayOutUnloadChunk_chunkX = ClientboundForgetLevelChunkPacket.class.getDeclaredField("a");
+            field_PacketPlayOutUnloadChunk_chunkZ = ClientboundForgetLevelChunkPacket.class.getDeclaredField("b");
+            field_PacketPlayOutViewDistance_distance = ClientboundSetChunkCacheRadiusPacket.class.getDeclaredField("a");
+            field_ClientboundLevelChunkWithLightPacket_chunkX = ClientboundLevelChunkWithLightPacket.class.getDeclaredField("a");
+            field_ClientboundLevelChunkWithLightPacket_chunkZ = ClientboundLevelChunkWithLightPacket.class.getDeclaredField("b");
+            field_PacketPlayOutUnloadChunk_chunkX.setAccessible(true);
+            field_PacketPlayOutUnloadChunk_chunkZ.setAccessible(true);
+            field_PacketPlayOutViewDistance_distance.setAccessible(true);
+            field_ClientboundLevelChunkWithLightPacket_chunkX.setAccessible(true);
+            field_ClientboundLevelChunkWithLightPacket_chunkZ.setAccessible(true);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public static boolean write(Player player, Packet<?> packet) {
+        try {
+            if (packet instanceof ClientboundForgetLevelChunkPacket) {
+                PacketUnloadChunkEvent event = new PacketUnloadChunkEvent(player, field_PacketPlayOutUnloadChunk_chunkX.getInt(packet), field_PacketPlayOutUnloadChunk_chunkZ.getInt(packet));
+                Bukkit.getPluginManager().callEvent(event);
+                PlayerChunkView view = ZeroChunk.getInstance().getView(event.getPlayer());
+                if (view.viewAPI.isChunkSend(event.getChunkX(), event.getChunkZ())) return true;
+                return !event.isCancelled();
+            } else if (packet instanceof ClientboundSetChunkCacheRadiusPacket) {
+                PacketViewDistanceEvent event = new PacketViewDistanceEvent(player, field_PacketPlayOutViewDistance_distance.getInt(packet));
+                Bukkit.getPluginManager().callEvent(event);
+                PlayerChunkView view = ZeroChunk.getInstance().getView(event.getPlayer());
+                int viewDistance = event.getViewDistance();
+                if (view != null && view.getMap().extendDistance != viewDistance && viewDistance != 0) return true;
+                return !event.isCancelled();
+            } else if (packet instanceof ClientboundLevelChunkWithLightPacket) {
+                PacketMapChunkEvent event = new PacketMapChunkEvent(player, field_ClientboundLevelChunkWithLightPacket_chunkX.getInt(packet), field_ClientboundLevelChunkWithLightPacket_chunkZ.getInt(packet));
+                Bukkit.getPluginManager().callEvent(event);
+                if (!event.isCancelled()) ZeroChunk.getInstance().packetEvent(event.getPlayer(), event);
+                return !event.isCancelled();
+            } else {
+                return true;
+            }
+        } catch (Exception ex) {
+            ex.printStackTrace();
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/CumulativeReport.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/CumulativeReport.java
new file mode 100644
index 0000000000000000000000000000000000000000..e082bf98004e920f866393b14eb59a37af1c9de0
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/CumulativeReport.java
@@ -0,0 +1,102 @@
+package com.github.ipecter.fusion.zerochunk.data;
+
+/**
+ * 累計處裡報告
+ */
+public final class CumulativeReport {
+    /** 高速讀取 */
+    private volatile int[] loadFast = new int[300];
+    /** 慢速讀取 */
+    private volatile int[] loadSlow = new int[300];
+    /** 消耗 */
+    private volatile int[] consume = new int[300];
+
+
+    public void next() {
+        try {
+            // 累計用向後推移1個
+            int[] loadFastClone = new int[300];
+            int[] loadSlowClone = new int[300];
+            int[] consumeClone = new int[300];
+            System.arraycopy(loadFast, 0, loadFastClone, 1, loadFast.length - 1);
+            System.arraycopy(loadSlow, 0, loadSlowClone, 1, loadSlow.length - 1);
+            System.arraycopy(consume, 0, consumeClone, 1, consume.length - 1);
+            loadFast = loadFastClone;
+            loadSlow = loadSlowClone;
+            consume = consumeClone;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+
+    public void increaseLoadFast() {
+        loadFast[0]++;
+    }
+    public void increaseLoadSlow() {
+        loadSlow[0]++;
+    }
+    public void addConsume(int value) {
+        consume[0] += value;
+    }
+
+
+    public int reportLoadFast5s() {
+        int total = 0;
+        for (int i = 0 ; i < 5 ; ++i)
+            total += loadFast[i];
+        return total;
+    }
+    public int reportLoadFast1m() {
+        int total = 0;
+        for (int i = 0 ; i < 60 ; ++i)
+            total += loadFast[i];
+        return total;
+    }
+    public int reportLoadFast5m() {
+        int total = 0;
+        for (int i = 0 ; i < 300 ; ++i)
+            total += loadFast[i];
+        return total;
+    }
+
+
+    public int reportLoadSlow5s() {
+        int total = 0;
+        for (int i = 0 ; i < 5 ; ++i)
+            total += loadSlow[i];
+        return total;
+    }
+    public int reportLoadSlow1m() {
+        int total = 0;
+        for (int i = 0 ; i < 60 ; ++i)
+            total += loadSlow[i];
+        return total;
+    }
+    public int reportLoadSlow5m() {
+        int total = 0;
+        for (int i = 0 ; i < 300 ; ++i)
+            total += loadSlow[i];
+        return total;
+    }
+
+
+    public long reportConsume5s() {
+        long total = 0;
+        for (int i = 0 ; i < 5 ; ++i)
+            total += consume[i];
+        return total;
+    }
+    public long reportConsume1m() {
+        long total = 0;
+        for (int i = 0 ; i < 60 ; ++i)
+            total += consume[i];
+        return total;
+    }
+    public long reportConsume5m() {
+        long total = 0;
+        for (int i = 0 ; i < 300 ; ++i)
+            total += consume[i];
+        return total;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/LangFiles.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/LangFiles.java
new file mode 100644
index 0000000000000000000000000000000000000000..c3bfb45f28d0f29709850e16ed8be0d7c53463a9
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/LangFiles.java
@@ -0,0 +1,87 @@
+package com.github.ipecter.fusion.zerochunk.data;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/** 語言文件 */
+public final class LangFiles {
+    /** 全部語言文件 */
+    private final Map<Locale, JsonObject> fileMap = new ConcurrentHashMap<>();
+    /** 預設語言文件 */
+    private final JsonObject defaultMap = loadLang(Locale.ENGLISH);
+
+
+    /**
+     * @param sender 執行人
+     * @param key 條目鑰匙
+     * @return 語言條目
+     */
+    public String get(CommandSender sender, String key) {
+        if (sender instanceof Player) {
+            try {
+                // 1.16 以上
+                return get(((Player) sender).locale(), key);
+            } catch (NoSuchMethodError noSuchMethodError) {
+                return get(parseLocale(((Player) sender).getLocale()), key);
+            }
+        } else {
+            return get(Locale.ENGLISH, key);
+        }
+    }
+    private static Locale parseLocale(String string) {
+        String[] segments = string.split("_", 3);
+        int length = segments.length;
+        switch (length) {
+            case 1:
+                return new Locale(string);
+            case 2:
+                return new Locale(segments[0], segments[1]);
+            case 3:
+                return new Locale(segments[0], segments[1], segments[2]);
+            default:
+                return null;
+        }
+    }
+    /**
+     * @param locale 語言類型
+     * @param key 條目鑰匙
+     * @return 語言條目
+     */
+    public String get(Locale locale, String key) {
+        JsonObject lang = fileMap.computeIfAbsent(locale, v -> loadLang(locale));
+        JsonElement element = lang.get(key);
+        if (element != null && !element.isJsonNull()) {
+            return element.getAsString();
+        } else {
+            return defaultMap.get(key).getAsString();
+        }
+    }
+    /**
+     * @param locale 語言類型
+     * @return 讀取語言文件
+     */
+    private JsonObject loadLang(Locale locale) {
+        URL url = getClass().getClassLoader().getResource("lang/" + locale.toString().toLowerCase(Locale.ROOT) + ".json");
+        if (url == null)
+            return new JsonObject();
+        try {
+            URLConnection connection = url.openConnection();
+            connection.setUseCaches(true);
+            return new Gson().fromJson(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8), JsonObject.class);
+        } catch (IOException exception) {
+            return new JsonObject();
+        }
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/NetworkSpeed.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/NetworkSpeed.java
new file mode 100644
index 0000000000000000000000000000000000000000..e8fd5694e3119a20b1d096143f1c3a20dc2893ac
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/NetworkSpeed.java
@@ -0,0 +1,77 @@
+package com.github.ipecter.fusion.zerochunk.data;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * 網路速度監聽器
+ */
+public final class NetworkSpeed {
+    /** 測速用時間戳 */
+    public volatile long speedTimestamp = 0;
+    /** 測速用數據量 */
+    public volatile int speedConsume = 0;
+    /** 測速用 ID */
+    public volatile Long speedID = null;
+
+    /** 延遲用時間戳 */
+    public volatile long pingTimestamp = 0;
+    /** 延遲用 ID */
+    public volatile Long pingID = null;
+    /** 最後一次的延遲 */
+    public volatile int lastPing = 0;
+
+    /** 寫入紀錄 */
+    private volatile int[] writeArray = new int[50];
+    /** 延遲紀錄 */
+    private volatile int[] consumeArray = new int[50];
+    /** 寫入累計 */
+    private final AtomicInteger writeTotal = new AtomicInteger(0);
+    /** 寫入累計 */
+    private final AtomicInteger consumeTotal = new AtomicInteger(0);
+
+
+    /**
+     * 加入
+     */
+    public void add(int ping, int length) {
+        synchronized (writeTotal) {
+            writeTotal.addAndGet(length);
+            consumeTotal.addAndGet(ping);
+            writeArray[0] += length;
+            consumeArray[0] += ping;
+        }
+    }
+
+
+    /**
+     * @return 平均速度
+     */
+    public int avg() {
+        synchronized (writeTotal) {
+            int writeGet = writeTotal.get();
+            int consumeGet = Math.max(1, consumeTotal.get());
+            if (writeGet == 0) {
+                return 0;
+            } else {
+                return writeGet / consumeGet;
+            }
+        }
+    }
+
+
+    /**
+     * 下一個 tick
+     */
+    public void next() {
+        synchronized (writeTotal) {
+            writeTotal.addAndGet(-writeArray[writeArray.length - 1]);
+            consumeTotal.addAndGet(-consumeArray[consumeArray.length - 1]);
+            int[] writeArrayClone = new int[writeArray.length];
+            int[] consumeArrayClone = new int[consumeArray.length];
+            System.arraycopy(writeArray, 0, writeArrayClone, 1, writeArray.length - 1);
+            System.arraycopy(consumeArray, 0, consumeArrayClone, 1, consumeArray.length - 1);
+            writeArray = writeArrayClone;
+            consumeArray = consumeArrayClone;
+        }
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/NetworkTraffic.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/NetworkTraffic.java
new file mode 100644
index 0000000000000000000000000000000000000000..3dedec745cb7cefcb3ccd646fd56083a78dd786d
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/NetworkTraffic.java
@@ -0,0 +1,59 @@
+package com.github.ipecter.fusion.zerochunk.data;
+
+/**
+ * 網路流量
+ */
+public final class NetworkTraffic {
+//    /** 寫入紀錄 */
+//    private volatile int[] writeArray = new int[20];
+//    /** 寫入累計 */
+//    private final AtomicInteger writeTotal = new AtomicInteger(0);
+    private volatile int value = 0;
+
+
+    /**
+     * 已使用
+     * @param length 位元組數量
+     */
+    public synchronized void use(int length) {
+        value += length;
+//        synchronized (writeTotal) {
+//            writeArray[0] += length;
+//            writeTotal.addAndGet(length);
+//        }
+    }
+
+    /**
+     * @return 當前的狀態
+     */
+    public synchronized int get() {
+        return value;
+//        synchronized (writeTotal) {
+//            return writeTotal.get();
+//        }
+    }
+
+    /**
+     * @param length 位元組數量
+     * @return 是否低於使用量
+     */
+    public synchronized boolean exceed(int length) {
+        return value >= length;
+//        synchronized (writeTotal) {
+//            return writeTotal.get() >= length;
+//        }
+    }
+
+    /**
+     * 下一個 tick
+     */
+    public void next() {
+        value = 0;
+//        synchronized (writeTotal) {
+//            writeTotal.addAndGet(-writeArray[writeArray.length - 1]);
+//            int[] writeArrayClone = new int[writeArray.length];
+//            System.arraycopy(writeArray, 0, writeArrayClone, 1, writeArray.length - 1);
+//            writeArray = writeArrayClone;
+//        }
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/PlayerChunkView.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/PlayerChunkView.java
new file mode 100644
index 0000000000000000000000000000000000000000..48085740547cecc9387943d64bec4ab26d9c60ea
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/PlayerChunkView.java
@@ -0,0 +1,306 @@
+package com.github.ipecter.fusion.zerochunk.data;
+
+import com.github.ipecter.fusion.configuraions.LithiumConfig;
+import com.github.ipecter.fusion.configuraions.ZeroChunkConfig;
+import com.github.ipecter.fusion.configuraions.ZeroChunkWorldConfig;
+import com.github.ipecter.fusion.zerochunk.ZeroChunk;
+import com.github.ipecter.fusion.zerochunk.branch.BranchPacket;
+import com.github.ipecter.fusion.zerochunk.data.viewmap.ViewMap;
+import com.github.ipecter.fusion.zerochunk.data.viewmap.ViewShape;
+import com.github.ipecter.fusion.zerochunk.event.*;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.WorldBorder;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Player;
+
+import java.util.Map;
+
+/** 玩家視圖計算器 */
+public final class PlayerChunkView {
+    public  final PlayerView viewAPI;
+    private final Player player;
+    private final BranchPacket branchPacket;
+    /** 視圖計算器 */
+    private final ViewMap mapView;
+    /** 強制視野距離 */
+    public Integer forciblyMaxDistance = null;
+    /** 強制每秒能傳輸多少數據 (單位 bytes) */
+    public Integer forciblySendSecondMaxBytes = null;
+    /** 最後的視野距離 */
+    private int lastDistance = 0;
+    private ZeroChunkConfig configData;
+    /** 延遲時間戳 */
+    private long delayTime;
+    /** 已卸除 */
+    private boolean isUnload = false;
+    /** 最後世界 */
+    private World lastWorld;
+    /** 最後座標 */
+    private Location oldLocation = null;
+    /** 移動過快 */
+    public volatile boolean moveTooFast = false;
+    /** 網路流量 */
+    public final NetworkTraffic networkTraffic = new NetworkTraffic();
+    /** 網路速度 */
+    public final NetworkSpeed networkSpeed = new NetworkSpeed();
+    /** 等待發送 */
+    public volatile boolean waitSend = false;
+    /** 同步鑰匙 */
+    public volatile long syncKey;
+    /** 報告 */
+    public final CumulativeReport cumulativeReport = new CumulativeReport();
+    /** 檢查權限 */
+    private Long permissionsCheck = null;
+    /** 權限命中 */
+    private Integer permissionsHit = null;
+    /** 權限需要檢查 */
+    public boolean permissionsNeed = true;
+
+
+    public PlayerChunkView(Player player, ViewShape viewShape, BranchPacket branchPacket) {
+        this.player = player;
+        this.branchPacket = branchPacket;
+        this.mapView = configData.zeroChunkMaxViewDistance.createMap(viewShape);
+        this.lastWorld = player.getWorld();
+        this.syncKey = ZeroChunk.getInstance().random.nextLong();
+
+        updateDistance();
+        delay();
+
+        mapView.setCenter(player.getLocation());
+
+        this.viewAPI = new PlayerView(this);
+        Bukkit.getPluginManager().callEvent(new PlayerInitViewEvent(viewAPI));
+    }
+
+
+    private int serverDistance() {
+        return 1;
+    }
+
+
+    public void updateDistance() {
+        updateDistance(false);
+    }
+    private void updateDistance(boolean forcibly) {
+        int newDistance = max();
+        synchronized (mapView) {
+            mapView.serverDistance = serverDistance();
+            if (newDistance < mapView.serverDistance) {
+                newDistance = mapView.serverDistance;
+            }
+        }
+
+        if (forcibly || lastDistance != newDistance) {
+//            mapView.markOutsideWait(newDistance);
+            lastDistance = newDistance;
+            mapView.extendDistance = newDistance;
+            PlayerSendViewDistanceEvent event = new PlayerSendViewDistanceEvent(viewAPI, newDistance);
+            Bukkit.getPluginManager().callEvent(event);
+            if (!event.isCancelled())
+                branchPacket.sendViewDistance(player, event.getDistance());
+        }
+    }
+
+
+    private double square(double num) {
+        return num * num;
+    }
+
+
+    public boolean overSpeed() {
+        return overSpeed(player.getLocation());
+    }
+    public boolean overSpeed(Location location) {
+        CraftWorld craftWorld = (CraftWorld)lastWorld;
+        ZeroChunkWorldConfig configWorld = (ZeroChunkWorldConfig) craftWorld.getHandle().fusionConfig;
+        if (configWorld.zeroChunkSpeedingNotSend == -1) {
+            return false;
+        } else {
+            double speed = 0;
+
+            if (oldLocation != null && oldLocation.getWorld() == location.getWorld())
+                speed = Math.sqrt(square(oldLocation.getX() - location.getX()) + square(oldLocation.getZ() - location.getZ()));
+            oldLocation = location;
+
+            // 檢查速度是否太快 (水平飛行速度 > ? 方塊)
+            return speed > configWorld.zeroChunkSpeedingNotSend;
+        }
+    }
+
+
+    public synchronized boolean move() {
+        return move(player.getLocation());
+    }
+    public synchronized boolean move(Location location) {
+        return move(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+    public synchronized boolean move(int chunkX, int chunkZ) {
+        if (isUnload)
+            return false;
+
+        if (player.getWorld() != lastWorld) {
+            unload();
+            return false;
+        }
+
+        int hitX;
+        int hitZ;
+        PlayerSendUnloadChunkEvent event;
+        for (long chunkKey : mapView.movePosition(chunkX, chunkZ)) {
+            hitX = ViewMap.getX(chunkKey);
+            hitZ = ViewMap.getZ(chunkKey);
+            event = new PlayerSendUnloadChunkEvent(viewAPI, hitX, hitZ);
+            Bukkit.getPluginManager().callEvent(event);
+            if (!event.isCancelled())
+                branchPacket.sendUnloadChunk(player, hitX, hitZ);
+        }
+
+        return true;
+    }
+
+
+    public void delay() {
+        delay(System.currentTimeMillis() + ((ZeroChunkWorldConfig) ((CraftWorld)lastWorld).getHandle().fusionConfig).zeroChunkDelayBeforeSend);
+    }
+    public void delay(long delayTime) {
+        this.delayTime = delayTime;
+    }
+
+    public Long next() {
+        if (player.getWorld() != lastWorld) {
+            unload();
+            return null;
+        }
+
+        if (isUnload)
+            return null;
+
+        if (delayTime >= System.currentTimeMillis())
+            return null;
+
+        Long        chunkKey    = mapView.get();
+        if (chunkKey == null)
+            return null;
+
+        WorldBorder worldBorder         = lastWorld.getWorldBorder();
+        int         chunkX              = ViewMap.getX(chunkKey);
+        int         chunkZ              = ViewMap.getZ(chunkKey);
+        Location    borderCenter        = worldBorder.getCenter();
+        int         borderSizeRadius    = (int) worldBorder.getSize() / 2;
+        int         borderMinX          = ((borderCenter.getBlockX() - borderSizeRadius) >> 4) - 1;
+        int         borderMaxX          = ((borderCenter.getBlockX() + borderSizeRadius) >> 4) + 1;
+        int         borderMinZ          = ((borderCenter.getBlockZ() - borderSizeRadius) >> 4) - 1;
+        int         borderMaxZ          = ((borderCenter.getBlockZ() + borderSizeRadius) >> 4) + 1;
+
+        return borderMinX <= chunkX && chunkX <= borderMaxX && borderMinZ <= chunkZ && chunkZ <= borderMaxZ ? chunkKey : null;
+    }
+
+
+    public void unload() {
+        if (!isUnload) {
+            delay();
+            syncKey = ZeroChunk.getInstance().random.nextLong();
+            isUnload = true;
+            branchPacket.sendViewDistance(player, 0);
+            branchPacket.sendViewDistance(player, mapView.extendDistance);
+            mapView.clear();
+        }
+    }
+
+
+    public boolean install() {
+        if (isUnload) {
+            delay();
+            mapView.clear();
+            updateDistance(true);
+
+            lastWorld   = player.getWorld();
+            isUnload    = false;
+            return true;
+        }
+        return false;
+    }
+
+
+    public void send(int x, int z) {
+        PlayerViewMarkSendChunkEvent event = new PlayerViewMarkSendChunkEvent(viewAPI, x, z);
+        Bukkit.getPluginManager().callEvent(event);
+        if (!event.isCancelled())
+            mapView.markSendPosition(x, z);
+    }
+
+
+    public void remove(int x, int z) {
+        PlayerViewMarkWaitChunkEvent event = new PlayerViewMarkWaitChunkEvent(viewAPI, x, z);
+        Bukkit.getPluginManager().callEvent(event);
+        if (!event.isCancelled())
+            mapView.markWaitPosition(x, z);
+    }
+
+
+    public int max() {
+        CraftWorld craftWorld = (CraftWorld)lastWorld;
+        ZeroChunkWorldConfig configWorld = (ZeroChunkWorldConfig) craftWorld.getHandle().fusionConfig;
+        int viewDistance = configWorld.zeroChunkMaxViewDistance;
+        int clientViewDistance = player.getClientViewDistance();
+        Integer forciblyViewDistance = forciblyMaxDistance;
+
+        PlayerCheckViewDistanceEvent event = new PlayerCheckViewDistanceEvent(viewAPI, serverDistance(), clientViewDistance, viewDistance);
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (event.getForciblyDistance() != null) {
+            viewDistance = event.getForciblyDistance();
+        } else if (forciblyViewDistance != null) {
+            viewDistance = forciblyViewDistance;
+        } else if (permissionsNeed || (configData.zeroChunkPermissionsPeriodicMillisecondCheck != -1 && (permissionsCheck == null || permissionsCheck <= System.currentTimeMillis() - Long.valueOf(configData.zeroChunkPermissionsPeriodicMillisecondCheck)))) {
+            permissionsNeed = false;
+            permissionsCheck = System.currentTimeMillis();
+            permissionsHit = null;
+            // 檢查權限節點
+            for (Map.Entry<String, Integer> permissionsNodeEntry : configData.zeroChunkPermissionsNodeList) {
+                int permissionViewDistance = permissionsNodeEntry.getValue();
+                if (permissionViewDistance <= configWorld.zeroChunkMaxViewDistance && (permissionsHit == null || permissionViewDistance > permissionsHit) && player.hasPermission(permissionsNodeEntry.getKey())) {
+                    permissionsHit = permissionViewDistance;
+                }
+            }
+        }
+
+        if (permissionsHit != null)
+            viewDistance = permissionsHit;
+
+        if (viewDistance > clientViewDistance)
+            viewDistance = clientViewDistance;
+        if (viewDistance < 1)
+            viewDistance = 1;
+
+        return viewDistance;
+    }
+
+    public void clear() {
+        mapView.clear();
+    }
+
+
+    public void recalculate() {
+        mapView.markOutsideWait(mapView.serverDistance);
+    }
+
+    public ViewMap getMap() {
+        return mapView;
+    }
+
+    public World getLastWorld() {
+        return lastWorld;
+    }
+
+    public Player getPlayer() {
+        return player;
+    }
+
+    public long getDelayTime() {
+        return delayTime;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/PlayerView.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/PlayerView.java
new file mode 100644
index 0000000000000000000000000000000000000000..04a68c3baee1fba6c1ec7869aaf5c375171256d3
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/PlayerView.java
@@ -0,0 +1,184 @@
+package com.github.ipecter.fusion.zerochunk.data;
+
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.entity.Player;
+
+public final class PlayerView {
+    private final PlayerChunkView chunkView;
+
+
+    public PlayerView(PlayerChunkView chunkView) {
+        this.chunkView = chunkView;
+    }
+
+
+    public boolean isChunkSend(Location location) {
+        return isChunkSend(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+
+    public boolean isChunkSend(int chunkX, int chunkZ) {
+        return chunkView.getMap().isSendPosition(chunkX, chunkZ);
+    }
+
+
+    public boolean isChunkWait(Location location) {
+        return isChunkWait(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+
+    public boolean isChunkWait(int chunkX, int chunkZ) {
+        return chunkView.getMap().isWaitPosition(chunkX, chunkZ);
+    }
+
+
+    public boolean inChunk(Location location) {
+        return inChunk(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+
+    public boolean inChunk(int chunkX, int chunkZ) {
+        return chunkView.getMap().inPosition(chunkX, chunkZ);
+    }
+
+
+    public void setChunkSend(Location location) {
+        setChunkSend(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+
+    public void setChunkSend(int chunkX, int chunkZ) {
+        chunkView.getMap().markSendPosition(chunkX, chunkZ);
+    }
+
+
+    public void setChunkWait(Location location) {
+        setChunkWait(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+
+    public void setChunkWait(int chunkX, int chunkZ) {
+        chunkView.getMap().markWaitPosition(chunkX, chunkZ);
+    }
+
+
+    public int getNowExtendViewDistance() {
+        return chunkView.getMap().extendDistance;
+    }
+
+    public int getNowServerViewDistance() {
+        return chunkView.getMap().serverDistance;
+    }
+
+    public int getMaxExtendViewDistance() {
+        return chunkView.max();
+    }
+
+
+    public void setCenter(Location location) {
+        setCenter(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+
+    public void setCenter(int chunkX, int chunkZ) {
+        chunkView.getMap().setCenter(chunkX, chunkZ);
+    }
+
+
+    public Location getCenter() {
+        return new Location(chunkView.getLastWorld(), chunkView.getMap().getCenterX() << 4, 0, chunkView.getMap().getCenterZ() << 4);
+    }
+
+
+    public void clear() {
+        chunkView.getMap().clear();
+    }
+
+
+    public void unload() {
+        chunkView.unload();
+    }
+
+    public void install() {
+        chunkView.install();
+    }
+
+    public void recalculate() {
+        chunkView.recalculate();
+    }
+
+
+    public void setDelay(int delayTime) {
+        chunkView.delay(delayTime);
+    }
+
+    public long getDelay() {
+        return chunkView.getDelayTime();
+    }
+
+
+    public Player getPlayer() {
+        return chunkView.getPlayer();
+    }
+
+    public World getWorld() {
+        return chunkView.getLastWorld();
+    }
+
+
+    public void setForciblySendSecondMaxBytes(Integer value) {
+        chunkView.forciblySendSecondMaxBytes = value;
+    }
+
+    public Integer getForciblySendSecondMaxBytes() {
+        return chunkView.forciblySendSecondMaxBytes;
+    }
+
+
+    public void setForciblyMaxDistance(Integer value) {
+        chunkView.forciblyMaxDistance = value;
+    }
+
+    public Integer getForciblyMaxDistance() {
+        return chunkView.forciblyMaxDistance;
+    }
+
+
+    public int getNetworkSpeedAVG() {
+        return chunkView.networkSpeed.avg();
+    }
+
+
+    public int getNetworkReportLoadFast5s() {
+        return chunkView.cumulativeReport.reportLoadFast5s();
+    }
+
+    public int getNetworkReportLoadFast1m() {
+        return chunkView.cumulativeReport.reportLoadFast1m();
+    }
+
+    public int getNetworkReportLoadFast5m() {
+        return chunkView.cumulativeReport.reportLoadFast5m();
+    }
+
+
+    public int getNetworkReportLoadSlow5s() {
+        return chunkView.cumulativeReport.reportLoadSlow5s();
+    }
+
+    public int getNetworkReportLoadSlow1m() {
+        return chunkView.cumulativeReport.reportLoadSlow1m();
+    }
+
+    public int getNetworkReportLoadSlow5m() {
+        return chunkView.cumulativeReport.reportLoadSlow5m();
+    }
+
+
+    public long getNetworkReportConsume5s() {
+        return chunkView.cumulativeReport.reportConsume5s();
+    }
+
+    public long getNetworkReportConsume1m() {
+        return chunkView.cumulativeReport.reportConsume1m();
+    }
+
+    public long getNetworkReportConsume5m() {
+        return chunkView.cumulativeReport.reportConsume5m();
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/IntX15ViewMap.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/IntX15ViewMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..9fdd0326a6d8dab5d9d062d09fdd9dd71025f6f0
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/IntX15ViewMap.java
@@ -0,0 +1,594 @@
+package com.github.ipecter.fusion.zerochunk.data.viewmap;
+
+import org.bukkit.Location;
+import org.bukkit.command.CommandSender;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * 表示區塊視野
+ *
+ * @see LongX31ViewMap 的延伸版本
+ */
+public final class IntX15ViewMap extends ViewMap {
+    /*
+    每位玩家都有一個 long 陣列
+    最高 63 * 63 (因為求奇數)
+        0 表示等待中
+        1 表示已發送區塊
+    63 / 2 = 31 所以實際上最遠只能擴充 31 個視野距離
+
+    每個 long 的最後一位數用於其他資料標記
+
+    long[].length = 64
+
+                    chunkMap
+                    6   6          5          4            3          2          1          0
+                    3 2109876 54321098 76543210 98765432 1 0987654 32109876 54321098 76543210  位元位移
+
+                      33          2          1         0 0 0         1          2          33
+                      1098765 43210987 65432109 87654321 0 1234567 89012345 67890123 45678901  區塊離中心點多遠
+
+                   |-|-------|--------|--------|--------|- -------|--------|--------|--------|
+                   | |                                   *                                   | 表示 列 中心點
+                   |*|                                                                       | 不使用
+                   |-|------- -------- -------- -------- - ------- -------- -------- --------|
+          long[ 0] |0|0000000 00000000 00000000 00000000 0 0000000 00000000 00000000 00000000|
+          ...      | |                                 ...                                   |
+          long[31] | |                                 ...                                   | 表示 行 中心點
+          ...      | |                                 ...                                   |
+          long[62] |0|0000000 00000000 00000000 00000000 0 0000000 00000000 00000000 00000000|
+                   |-|-----------------------------------------------------------------------|
+
+
+     */
+    /**
+     * 距離
+     */
+    private static final int DISTANCE = 16;
+    /**
+     * 中心
+     */
+    private static final int CENTER = 15;
+    /**
+     * 長度
+     */
+    private static final int LENGTH = 31;
+    /**
+     * 視圖計算
+     */
+    private final int[] chunkMap = new int[LENGTH];
+    /**
+     * 已完成距離
+     */
+    private final AtomicInteger completedDistance = new AtomicInteger(-1);
+
+    public IntX15ViewMap(ViewShape viewShape) {
+        super(viewShape);
+    }
+
+
+    public List<Long> movePosition(Location location) {
+        return movePosition(blockToChunk(location.getX()), blockToChunk(location.getZ()));
+    }
+
+    /**
+     * 移動到區塊位置 (中心點)
+     *
+     * @param moveX 區塊座標X
+     * @param moveZ 區塊座標Z
+     * @return 如果有區塊被移除, 則會集中回傳在這
+     */
+    public List<Long> movePosition(int moveX, int moveZ) {
+        if (moveX != centerX || moveZ != centerZ) {
+            /*
+            先對 chunkMap 進行座標位移
+            再把伺服器視野距離的範圍標記為以加載
+             */
+            // 上一個紀錄的區塊位置 (中心點)
+            int viewDistance = Math.min(extendDistance + 1, DISTANCE);
+            // 移除的區塊清單
+            List<Long> removeKeys = new ArrayList<>();
+            // 將那些已經不再範圍內的區塊, 增加到緩存中
+            int hitDistance = Math.max(serverDistance, viewDistance + 1);
+            int pointerX;
+            int pointerZ;
+            int chunkX;
+            int chunkZ;
+            for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+                for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                    chunkX = (centerX - pointerX) + CENTER;
+                    chunkZ = (centerZ - pointerZ) + CENTER;
+                    // 是否已經不再範圍內
+                    if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, hitDistance) && !viewShape.isInside(moveX, moveZ, chunkX, chunkZ, hitDistance)) {
+                        if (markWaitSafe(pointerX, pointerZ)) {
+                            removeKeys.add(getPositionKey(chunkX, chunkZ));
+                        }
+                    }
+                }
+            }
+
+            /*
+               -      +
+               X
+            +Z |-------|
+               | Chunk |
+               | Map   |
+            -  |-------|
+
+            當座標發生移動
+            x:0    -> x:1
+            000000    000000
+            011110    111100
+            011110    111100
+            011110    111100
+            011110    111100
+            000000    000000
+
+            z:0    -> z:1
+            000000    000000
+            011110    000000
+            011110    011110
+            011110    011110
+            011110    011110
+            000000    011110
+            */
+            int offsetX = centerX - moveX;
+            int offsetZ = centerZ - moveZ;
+            // 座標X 發生改動
+            if (offsetX != 0) {
+                for (pointerZ = 0; pointerZ < LENGTH; pointerZ++) {
+                    chunkMap[pointerZ] = offsetX > 0 ? chunkMap[pointerZ] >> offsetX : chunkMap[pointerZ] << Math.abs(offsetX);
+                }
+            }
+            // 座標Z 發生改動
+            if (offsetZ != 0) {
+                int[] newChunkMap = new int[LENGTH];
+                int pointerToZ;
+                for (int pointerFromZ = 0; pointerFromZ < LENGTH; pointerFromZ++) {
+                    pointerToZ = pointerFromZ - offsetZ;
+                    if (pointerToZ >= 0 && pointerToZ < LENGTH) {
+                        newChunkMap[pointerToZ] = chunkMap[pointerFromZ];
+                    }
+                }
+                System.arraycopy(newChunkMap, 0, chunkMap, 0, chunkMap.length);
+            }
+
+            // 如果座標有發生改動, 更新目前儲存的座標
+            if (offsetX != 0 || offsetZ != 0) {
+                // 將沒有用到的地方標記為 0 (最左側)
+                if (offsetX < 0) {
+                    for (pointerZ = 0; pointerZ < LENGTH; pointerZ++)
+                        chunkMap[pointerZ] &= 0b01111111111111111111111111111111L;
+                }
+            }
+
+            if (moveX != centerX || moveZ != centerZ) {
+                completedDistance.addAndGet(-Math.max(Math.abs(centerX - moveX), Math.abs(centerZ - moveZ)));
+            }
+            centerX = moveX;
+            centerZ = moveZ;
+
+            return removeKeys;
+        } else {
+            return new ArrayList<>(0);
+        }
+    }
+
+
+    /**
+     * 取得下一個應該要處裡的區塊
+     *
+     * @return positionKey, 若沒有需要處裡的區塊, 則回傳 null
+     */
+    public Long get() {
+        /*
+        尋找過程
+        會從中心慢慢往外找
+
+        順時針, 從最上方開始
+         -----      -----      -----      -----      -----      -----      -----      -----      -----      -----      -----
+
+                                           1          11         111        111        111        111        111        111
+           +    ->    +    ->   1+    ->   1+    ->   1+    ->   1+    ->   1+1   ->   1+1   ->   1+1   ->   1+1   ->   1+1
+                     1          1          1          1          1          1          1 1        111        111       1111
+                                                                                                            1          1
+         -----      -----      -----      -----      -----      -----      -----      -----      -----      -----      -----
+
+
+        算公式
+         單個邊長
+        1 = 1 + (1 - 1)
+        3 = 2 + (2 - 1)
+        5 = 3 + (3 - 1)
+        7 = 4 + (4 - 1)
+
+         總邊長 (不重複步數)
+        0  = 1 * 4 - 4
+        8  = 3 * 4 - 4
+        16 = 5 * 4 - 4
+        24 = 7 * 4 - 4
+
+         edgeStepCount = 每移動?次 換方向 總要要換4次方向
+        0  / 4 = 0
+        8  / 4 = 2
+        16 / 4 = 4
+        24 / 4 = 6
+
+        得出的公式
+        每 距離+1 所需移動的次數+2
+
+        distance = 1    //
+        1               // 由於不可為 1
+        + 1             // 中心點掠過
+
+
+        distance = 2
+         3
+        |-|
+        | | 8
+        |-|
+
+
+        distance = 3
+          5
+        |---|
+        |   |
+        |   | 16
+        |   |
+        |---|
+
+
+        distance = 4
+           7
+        |-----|
+        |     |
+        |     |
+        |     | 24
+        |     |
+        |     |
+        |-----|
+
+         */
+
+        int viewDistance = Math.min(extendDistance + 1, DISTANCE);
+        int edgeStepCount = 0;  // 每個邊, 移動幾次換方向
+        int readX;
+        int readZ;
+        int pointerX;
+        int pointerZ;
+        int stepCount;
+        int chunkX;
+        int chunkZ;
+        boolean notMiss = true;
+
+        for (int distance = 0; distance < DISTANCE && distance < viewDistance; distance++) {
+            if (distance > completedDistance.get()) {
+                // 總共有 4 次方向
+                readX = distance;
+                readZ = distance;
+                pointerX = CENTER + distance;
+                pointerZ = CENTER + distance;
+
+                // Z--
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerZ--;
+                    readZ--;
+                }
+                // X--
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerX--;
+                    readX--;
+                }
+                // Z++
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerZ++;
+                    readZ++;
+                }
+                // X++
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerX++;
+                    readX++;
+                }
+
+                if (notMiss) {
+                    completedDistance.set(distance);
+                }
+            }
+
+            // 下一次循環
+            edgeStepCount += 2;
+        }
+        return null;
+    }
+
+
+    public boolean isWaitSafe(int pointerX, int pointerZ) {
+        return !isSendSafe(pointerX, pointerZ);
+    }
+
+    public boolean isSendSafe(int pointerX, int pointerZ) {
+        return ((chunkMap[pointerZ] >> pointerX) & 0b00000000000000000000000000000001) == 0b00000000000000000000000000000001;
+    }
+
+
+    public boolean markWaitSafe(int pointerX, int pointerZ) {
+        if (isSendSafe(pointerX, pointerZ)) {
+            chunkMap[pointerZ] ^= (0b00000000000000000000000000000001 << pointerX);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void markSendSafe(int pointerX, int pointerZ) {
+        chunkMap[pointerZ] |= (0b00000000000000000000000000000001 << pointerX);
+    }
+
+
+    public boolean inPosition(int positionX, int positionZ) {
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        return pointerX <= CENTER + extendDistance && pointerX >= CENTER - extendDistance && pointerZ <= CENTER + extendDistance && pointerZ >= CENTER - extendDistance;
+    }
+
+
+    public boolean isWaitPosition(long positionKey) {
+        int x = getX(positionKey);
+        int z = getZ(positionKey);
+        return isWaitPosition(x, z);
+    }
+
+    public boolean isWaitPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        return pointerX >= 0 && pointerX < LENGTH && pointerZ >= 0 && pointerZ < LENGTH && isWaitSafe(pointerX, pointerZ);
+    }
+
+    public boolean isSendPosition(long positionKey) {
+        int x = getX(positionKey);
+        int z = getZ(positionKey);
+        return isSendPosition(x, z);
+    }
+
+    public boolean isSendPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        return pointerX >= 0 && pointerX < LENGTH && pointerZ >= 0 && pointerZ < LENGTH && isSendSafe(pointerX, pointerZ);
+    }
+
+    public void markWaitPosition(long positionKey) {
+        int x = getX(positionKey);
+        int z = getZ(positionKey);
+        markWaitPosition(x, z);
+    }
+
+    public void markWaitPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        if (pointerX >= 0 && pointerX < LENGTH && pointerZ >= 0 && pointerZ < LENGTH)
+            markWaitSafe(pointerX, pointerZ);
+    }
+
+    public void markSendPosition(long positionKey) {
+        int x = getX(positionKey);
+        int z = getZ(positionKey);
+        markSendPosition(x, z);
+    }
+
+    public void markSendPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        if (pointerX >= 0 && pointerX < LENGTH && pointerZ >= 0 && pointerZ < LENGTH)
+            markSendSafe(pointerX, pointerZ);
+    }
+
+
+    /**
+     * @param range 範圍外的區塊標記為等待中
+     */
+    public void markOutsideWait(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markWaitSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+    /**
+     * @param range 範圍外的區塊標記為以發送
+     */
+    public void markOutsideSend(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markSendSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+
+    /**
+     * @param range 範圍內的區塊標記為等待中
+     */
+    public void markInsideWait(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markWaitSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+    /**
+     * @param range 範圍內的區塊標記為以發送
+     */
+    public void markInsideSend(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markSendSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+
+    public void clear() {
+        System.arraycopy(new int[LENGTH], 0, chunkMap, 0, chunkMap.length);
+        completedDistance.set(-1);
+    }
+
+
+    public int[] getChunkMap() {
+        return chunkMap;
+    }
+
+    public List<Long> getAll() {
+        List<Long> chunkList = new ArrayList<>();
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                chunkList.add(getPositionKey(chunkX, chunkZ));
+            }
+        }
+        return chunkList;
+    }
+
+    public List<Long> getAllNotServer() {
+        List<Long> chunkList = new ArrayList<>();
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (isSendSafe(pointerX, pointerZ) && !viewShape.isInside(centerX, centerZ, chunkX, chunkZ, serverDistance))
+                    chunkList.add(getPositionKey(chunkX, chunkZ));
+            }
+        }
+        return chunkList;
+    }
+
+
+    public static int blockToChunk(double blockLocation) {
+        return blockToChunk((int) blockLocation);
+    }
+
+    public static int blockToChunk(int blockLocation) {
+        return blockLocation >> 4;
+    }
+
+
+    public static String debug(int value) {
+        StringBuilder builder = new StringBuilder(LENGTH);
+        for (int i = LENGTH; i >= 0; i--) {
+            builder.append((value >> i & 1) == 1 ? '■' : '□');
+        }
+        return builder.toString();
+    }
+
+    public void debug(CommandSender sender) {
+        StringBuilder builder = new StringBuilder();
+        builder.append("IntX15ViewMap:\n");
+        for (int index = 0; index < LENGTH; ++index) {
+            if (index != 0)
+                builder.append('\n');
+            builder.append(debug(getChunkMap()[index]));
+        }
+        sender.sendMessage(builder.toString());
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/LongX31ViewMap.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/LongX31ViewMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..1dc737722d1d1e166f2a6fc72e1a6301e5f95897
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/LongX31ViewMap.java
@@ -0,0 +1,592 @@
+package com.github.ipecter.fusion.zerochunk.data.viewmap;
+
+import org.bukkit.Location;
+import org.bukkit.command.CommandSender;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * 表示區塊視野
+ */
+public final class LongX31ViewMap extends ViewMap {
+    /*
+    每位玩家都有一個 long 陣列
+    最高 63 * 63 (因為求奇數)
+        0 表示等待中
+        1 表示已發送區塊
+    63 / 2 = 31 所以實際上最遠只能擴充 31 個視野距離
+
+    每個 long 的最後一位數用於其他資料標記
+
+    long[].length = 63
+
+                    chunkMap
+                    6   6          5          4            3          2          1          0
+                    3 2109876 54321098 76543210 98765432 1 0987654 32109876 54321098 76543210  位元位移
+
+                      33          2          1         0 0 0         1          2          33
+                      1098765 43210987 65432109 87654321 0 1234567 89012345 67890123 45678901  區塊離中心點多遠
+
+                   |-|-------|--------|--------|--------|- -------|--------|--------|--------|
+                   | |                                   *                                   | 表示 列 中心點
+                   |*|                                                                       | 不使用
+                   |-|------- -------- -------- -------- - ------- -------- -------- --------|
+          long[ 0] |0|0000000 00000000 00000000 00000000 0 0000000 00000000 00000000 00000000|
+          ...      | |                                 ...                                   |
+          long[31] | |                                 ...                                   | 表示 行 中心點
+          ...      | |                                 ...                                   |
+          long[62] |0|0000000 00000000 00000000 00000000 0 0000000 00000000 00000000 00000000|
+                   |-|-----------------------------------------------------------------------|
+
+
+     */
+    /**
+     * 距離
+     */
+    private static final int DISTANCE = 32;
+    /**
+     * 中心
+     */
+    private static final int CENTER = 31;
+    /**
+     * 長度
+     */
+    private static final int LENGTH = 63;
+    /**
+     * 視圖計算
+     */
+    private final long[] chunkMap = new long[LENGTH];
+    /**
+     * 已完成距離
+     */
+    private final AtomicInteger completedDistance = new AtomicInteger(-1);
+
+    public LongX31ViewMap(ViewShape viewShape) {
+        super(viewShape);
+    }
+
+
+    public List<Long> movePosition(Location location) {
+        return movePosition(blockToChunk(location.getX()), blockToChunk(location.getZ()));
+    }
+
+    /**
+     * 移動到區塊位置 (中心點)
+     *
+     * @param moveX 區塊座標X
+     * @param moveZ 區塊座標Z
+     * @return 如果有區塊被移除, 則會集中回傳在這
+     */
+    public List<Long> movePosition(int moveX, int moveZ) {
+        if (moveX != centerX || moveZ != centerZ) {
+            /*
+            先對 chunkMap 進行座標位移
+            再把伺服器視野距離的範圍標記為以加載
+             */
+            // 上一個紀錄的區塊位置 (中心點)
+            int viewDistance = Math.min(extendDistance + 1, DISTANCE);
+            // 移除的區塊清單
+            List<Long> removeKeys = new ArrayList<>();
+            // 將那些已經不再範圍內的區塊, 增加到緩存中
+            int hitDistance = Math.max(serverDistance, viewDistance + 1);
+            int pointerX;
+            int pointerZ;
+            int chunkX;
+            int chunkZ;
+            for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+                for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                    chunkX = (centerX - pointerX) + CENTER;
+                    chunkZ = (centerZ - pointerZ) + CENTER;
+                    // 是否已經不再範圍內
+                    if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, hitDistance) && !viewShape.isInside(moveX, moveZ, chunkX, chunkZ, hitDistance)) {
+                        if (markWaitSafe(pointerX, pointerZ)) {
+                            removeKeys.add(getPositionKey(chunkX, chunkZ));
+                        }
+                    }
+                }
+            }
+
+            /*
+               -      +
+               X
+            +Z |-------|
+               | Chunk |
+               | Map   |
+            -  |-------|
+
+            當座標發生移動
+            x:0    -> x:1
+            000000    000000
+            011110    111100
+            011110    111100
+            011110    111100
+            011110    111100
+            000000    000000
+
+            z:0    -> z:1
+            000000    000000
+            011110    000000
+            011110    011110
+            011110    011110
+            011110    011110
+            000000    011110
+            */
+            int offsetX = centerX - moveX;
+            int offsetZ = centerZ - moveZ;
+            // 座標X 發生改動
+            if (offsetX != 0) {
+                for (pointerZ = 0; pointerZ < LENGTH; pointerZ++) {
+                    chunkMap[pointerZ] = offsetX > 0 ? chunkMap[pointerZ] >> offsetX : chunkMap[pointerZ] << Math.abs(offsetX);
+                }
+            }
+            // 座標Z 發生改動
+            if (offsetZ != 0) {
+                long[] newChunkMap = new long[LENGTH];
+                int pointerToZ;
+                for (int pointerFromZ = 0; pointerFromZ < LENGTH; pointerFromZ++) {
+                    pointerToZ = pointerFromZ - offsetZ;
+                    if (pointerToZ >= 0 && pointerToZ < LENGTH) {
+                        newChunkMap[pointerToZ] = chunkMap[pointerFromZ];
+                    }
+                }
+                System.arraycopy(newChunkMap, 0, chunkMap, 0, chunkMap.length);
+            }
+
+            // 如果座標有發生改動, 更新目前儲存的座標
+            if (offsetX != 0 || offsetZ != 0) {
+                // 將沒有用到的地方標記為 0 (最左側)
+                if (offsetX < 0) {
+                    for (pointerZ = 0; pointerZ < LENGTH; pointerZ++)
+                        chunkMap[pointerZ] &= 0b0111111111111111111111111111111111111111111111111111111111111111L;
+                }
+            }
+
+            if (moveX != centerX || moveZ != centerZ) {
+                completedDistance.addAndGet(-Math.max(Math.abs(centerX - moveX), Math.abs(centerZ - moveZ)));
+            }
+            centerX = moveX;
+            centerZ = moveZ;
+
+            return removeKeys;
+        } else {
+            return new ArrayList<>(0);
+        }
+    }
+
+
+    /**
+     * 取得下一個應該要處裡的區塊
+     *
+     * @return positionKey, 若沒有需要處裡的區塊, 則回傳 null
+     */
+    public Long get() {
+        /*
+        尋找過程
+        會從中心慢慢往外找
+
+        順時針, 從最上方開始
+         -----      -----      -----      -----      -----      -----      -----      -----      -----      -----      -----
+
+                                           1          11         111        111        111        111        111        111
+           +    ->    +    ->   1+    ->   1+    ->   1+    ->   1+    ->   1+1   ->   1+1   ->   1+1   ->   1+1   ->   1+1
+                     1          1          1          1          1          1          1 1        111        111       1111
+                                                                                                            1          1
+         -----      -----      -----      -----      -----      -----      -----      -----      -----      -----      -----
+
+
+        算公式
+         單個邊長
+        1 = 1 + (1 - 1)
+        3 = 2 + (2 - 1)
+        5 = 3 + (3 - 1)
+        7 = 4 + (4 - 1)
+
+         總邊長 (不重複步數)
+        0  = 1 * 4 - 4
+        8  = 3 * 4 - 4
+        16 = 5 * 4 - 4
+        24 = 7 * 4 - 4
+
+         edgeStepCount = 每移動?次 換方向 總要要換4次方向
+        0  / 4 = 0
+        8  / 4 = 2
+        16 / 4 = 4
+        24 / 4 = 6
+
+        得出的公式
+        每 距離+1 所需移動的次數+2
+
+        distance = 1    //
+        1               // 由於不可為 1
+        + 1             // 中心點掠過
+
+
+        distance = 2
+         3
+        |-|
+        | | 8
+        |-|
+
+
+        distance = 3
+          5
+        |---|
+        |   |
+        |   | 16
+        |   |
+        |---|
+
+
+        distance = 4
+           7
+        |-----|
+        |     |
+        |     |
+        |     | 24
+        |     |
+        |     |
+        |-----|
+
+         */
+
+        int viewDistance = Math.min(extendDistance + 1, DISTANCE);
+        int edgeStepCount = 0;  // 每個邊, 移動幾次換方向
+        int readX;
+        int readZ;
+        int pointerX;
+        int pointerZ;
+        int stepCount;
+        int chunkX;
+        int chunkZ;
+        boolean notMiss = true;
+
+        for (int distance = 0; distance < DISTANCE && distance < viewDistance; distance++) {
+            if (distance > completedDistance.get()) {
+                // 總共有 4 次方向
+                readX = distance;
+                readZ = distance;
+                pointerX = CENTER + distance;
+                pointerZ = CENTER + distance;
+
+                // Z--
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerZ--;
+                    readZ--;
+                }
+                // X--
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerX--;
+                    readX--;
+                }
+                // Z++
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerZ++;
+                    readZ++;
+                }
+                // X++
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerX++;
+                    readX++;
+                }
+
+                if (notMiss) {
+                    completedDistance.set(distance);
+                }
+            }
+
+            // 下一次循環
+            edgeStepCount += 2;
+        }
+        return null;
+    }
+
+
+    public boolean isWaitSafe(int pointerX, int pointerZ) {
+        return !isSendSafe(pointerX, pointerZ);
+    }
+
+    public boolean isSendSafe(int pointerX, int pointerZ) {
+        return ((chunkMap[pointerZ] >> pointerX) & 0b0000000000000000000000000000000000000000000000000000000000000001L) == 0b0000000000000000000000000000000000000000000000000000000000000001L;
+    }
+
+
+    public boolean markWaitSafe(int pointerX, int pointerZ) {
+        if (isSendSafe(pointerX, pointerZ)) {
+            chunkMap[pointerZ] ^= (0b0000000000000000000000000000000000000000000000000000000000000001L << pointerX);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void markSendSafe(int pointerX, int pointerZ) {
+        chunkMap[pointerZ] |= (0b0000000000000000000000000000000000000000000000000000000000000001L << pointerX);
+    }
+
+
+    public boolean inPosition(int positionX, int positionZ) {
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        return pointerX <= CENTER + extendDistance && pointerX >= CENTER - extendDistance && pointerZ <= CENTER + extendDistance && pointerZ >= CENTER - extendDistance;
+    }
+
+
+    public boolean isWaitPosition(long positionKey) {
+        int x = getX(positionKey);
+        int z = getZ(positionKey);
+        return isWaitPosition(x, z);
+    }
+
+    public boolean isWaitPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        return pointerX >= 0 && pointerX < LENGTH && pointerZ >= 0 && pointerZ < LENGTH && isWaitSafe(pointerX, pointerZ);
+    }
+
+    public boolean isSendPosition(long positionKey) {
+        int x = getX(positionKey);
+        int z = getZ(positionKey);
+        return isSendPosition(x, z);
+    }
+
+    public boolean isSendPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        return pointerX >= 0 && pointerX < LENGTH && pointerZ >= 0 && pointerZ < LENGTH && isSendSafe(pointerX, pointerZ);
+    }
+
+    public void markWaitPosition(long positionKey) {
+        int x = getX(positionKey);
+        int z = getZ(positionKey);
+        markWaitPosition(x, z);
+    }
+
+    public void markWaitPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        if (pointerX >= 0 && pointerX < LENGTH && pointerZ >= 0 && pointerZ < LENGTH)
+            markWaitSafe(pointerX, pointerZ);
+    }
+
+    public void markSendPosition(long positionKey) {
+        int x = getX(positionKey);
+        int z = getZ(positionKey);
+        markSendPosition(x, z);
+    }
+
+    public void markSendPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = CENTER + (centerX - positionX);
+        int pointerZ = CENTER + (centerZ - positionZ);
+        if (pointerX >= 0 && pointerX < LENGTH && pointerZ >= 0 && pointerZ < LENGTH)
+            markSendSafe(pointerX, pointerZ);
+    }
+
+
+    /**
+     * @param range 範圍外的區塊標記為等待中
+     */
+    public void markOutsideWait(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markWaitSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+    /**
+     * @param range 範圍外的區塊標記為以發送
+     */
+    public void markOutsideSend(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markSendSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+
+    /**
+     * @param range 範圍內的區塊標記為等待中
+     */
+    public void markInsideWait(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markWaitSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+    /**
+     * @param range 範圍內的區塊標記為以發送
+     */
+    public void markInsideSend(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markSendSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+
+    public void clear() {
+        System.arraycopy(new long[LENGTH], 0, chunkMap, 0, chunkMap.length);
+        completedDistance.set(-1);
+    }
+
+
+    public long[] getChunkMap() {
+        return chunkMap;
+    }
+
+    public List<Long> getAll() {
+        List<Long> chunkList = new ArrayList<>();
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                chunkList.add(getPositionKey(chunkX, chunkZ));
+            }
+        }
+        return chunkList;
+    }
+
+    public List<Long> getAllNotServer() {
+        List<Long> chunkList = new ArrayList<>();
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < LENGTH; ++pointerX) {
+            for (pointerZ = 0; pointerZ < LENGTH; ++pointerZ) {
+                chunkX = centerX + pointerX - CENTER;
+                chunkZ = centerZ + pointerZ - CENTER;
+                if (isSendSafe(pointerX, pointerZ) && !viewShape.isInside(centerX, centerZ, chunkX, chunkZ, serverDistance))
+                    chunkList.add(getPositionKey(chunkX, chunkZ));
+            }
+        }
+        return chunkList;
+    }
+
+
+    public static int blockToChunk(double blockLocation) {
+        return blockToChunk((int) blockLocation);
+    }
+
+    public static int blockToChunk(int blockLocation) {
+        return blockLocation >> 4;
+    }
+
+
+    public static String debug(long value) {
+        StringBuilder builder = new StringBuilder(LENGTH);
+        for (int i = LENGTH; i >= 0; i--) {
+            builder.append((value >> i & 1) == 1 ? '■' : '□');
+        }
+        return builder.toString();
+    }
+
+    public void debug(CommandSender sender) {
+        StringBuilder builder = new StringBuilder();
+        builder.append("LongX31ViewMap:\n");
+        for (int index = 0; index < LENGTH; ++index) {
+            if (index != 0)
+                builder.append('\n');
+            builder.append(debug(getChunkMap()[index]));
+        }
+        sender.sendMessage(builder.toString());
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/LongXInfinitelyViewMap.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/LongXInfinitelyViewMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ab2c2a0abce83159d790e51105f39c466a645d7
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/LongXInfinitelyViewMap.java
@@ -0,0 +1,516 @@
+package com.github.ipecter.fusion.zerochunk.data.viewmap;
+
+import org.bukkit.Location;
+import org.bukkit.command.CommandSender;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * 可以無限增加的視圖計算器
+ */
+public final class LongXInfinitelyViewMap extends ViewMap {
+    /*
+    每位玩家都有一個 long 陣列
+    最高 255 * 255 (因為求奇數)
+        0 表示等待中
+        1 表示已發送區塊
+    (255 - 1) / 2 = 127 所以實際上最遠只能擴充 63 個視野距離
+
+    每個 long 的最後一位數用於其他資料標記
+
+    long[].length = 255
+           long                                                                   long                                                                    long                                                                     long
+                 0        8        16       24       32       40       48       56       64       72       80       88       96       104      112      120        128      136      144      152      160      168      176      184      192      200      208      216      224      232      240      248
+                |--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|------- -| --------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|------|--|
+      long[  0] |                                                                       |                                                                       *|                                                                        |                                                                     |  | 縱軸中心點
+                |--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|------- -| --------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|------|--|
+            ... |                                                                       |                                                                        |                                                                        |                                                                     |  |
+      long[127] |                                                                       |                                                                        |                                                                        |                                                                     |  | 橫軸中心點
+            ... |                                                                       |                                                                        |                                                                        |                                                                     |  |
+      long[254] |--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|------- -| --------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|------|--|
+     */
+    /**
+     * 視圖計算
+     */
+    private final long[] viewData;
+    /**
+     * 單行 long 數量
+     */
+    private final int rowStack;
+    /**
+     * 半行 long 數量
+     */
+    private final int rowStackOffset;
+    /**
+     * 最大半徑塊數
+     */
+    private final int maxRadius;
+    /**
+     * 最大直徑塊數
+     */
+    private final int maxDiameter;
+    /**
+     * 已完成距離
+     */
+    private final AtomicInteger completedDistance = new AtomicInteger(-1);
+
+    public LongXInfinitelyViewMap(ViewShape viewShape, int row) {
+        super(viewShape);
+        rowStack = row;
+        rowStackOffset = rowStack / 2;
+        maxRadius = rowStackOffset * 64 - 1;
+        maxDiameter = rowStack * 64 - 1;
+        viewData = new long[maxDiameter << rowStackOffset];
+    }
+
+
+    public List<Long> movePosition(Location location) {
+        return movePosition(blockToChunk(location.getX()), blockToChunk(location.getZ()));
+    }
+
+    /**
+     * 移動到區塊位置 (中心點)
+     *
+     * @param moveX 區塊座標X
+     * @param moveZ 區塊座標Z
+     * @return 如果有區塊被移除, 則會集中回傳在這
+     */
+    public List<Long> movePosition(int moveX, int moveZ) {
+        if (moveX != centerX || moveZ != centerZ) {
+            /*
+               -      +
+               X
+            +Z |-------|
+               | Chunk |
+               | Map   |
+            -  |-------|
+             */
+            int viewDistance = Math.min(maxRadius, extendDistance + 1);
+            // 上一個紀錄的區塊位置 (中心點)
+            List<Long> removeKeys = new ArrayList<>();
+            // 將那些已經不再範圍內的區塊, 增加到緩存中
+            int hitDistance = Math.max(serverDistance, viewDistance + 1);
+            int pointerX;
+            int pointerZ;
+            int chunkX;
+            int chunkZ;
+            for (pointerX = 0; pointerX < maxDiameter; ++pointerX) {
+                for (pointerZ = 0; pointerZ < maxDiameter; ++pointerZ) {
+                    chunkX = (centerX - pointerX) + maxRadius;
+                    chunkZ = (centerZ - pointerZ) + maxRadius;
+                    // 是否已經不再範圍內
+                    if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, hitDistance) && !viewShape.isInside(moveX, moveZ, chunkX, chunkZ, hitDistance)) {
+                        if (markWaitSafe(pointerX, pointerZ)) {
+                            removeKeys.add(getPositionKey(chunkX, chunkZ));
+                        }
+                    }
+                }
+            }
+
+            int offsetX = centerX - moveX;
+            int offsetZ = centerZ - moveZ;
+            // 座標X 發生改動
+            if (offsetX != 0) {
+                long[] dataX = new long[rowStack];
+                long newX;
+                int rowX;
+                int migrate;
+                int redressX;
+                for (pointerZ = 0; pointerZ < maxDiameter; pointerZ++) {
+                    for (rowX = 0; rowX < rowStack; rowX++)
+                        dataX[rowX] = viewData[(pointerZ << rowStackOffset) | rowX];
+                    for (rowX = 0; rowX < rowStack; rowX++) {
+                        newX = 0;
+                        for (migrate = 0; migrate < rowStack; migrate++) {
+                            redressX = -(rowX - migrate) * 64 - offsetX;
+                            if (redressX < -64 || redressX > 64) {
+                            } else if (redressX < 0) {
+                                newX |= dataX[migrate] << -redressX;
+                            } else if (redressX > 0) {
+                                newX |= dataX[migrate] >>> redressX;
+                            }
+                        }
+                        if (rowX == rowStack - 1)
+                            // 將沒有用到的地方標記為 0 (最右側)
+                            newX &= 0b1111111111111111111111111111111111111111111111111111111111111110L;
+                        viewData[(pointerZ << rowStackOffset) | rowX] = newX;
+                    }
+                }
+            }
+
+            // 座標Z 發生改動
+            if (offsetZ < 0) {
+                int redressZ;
+                int rowX;
+                for (pointerZ = maxDiameter - 1; pointerZ >= 0; pointerZ--) {
+                    redressZ = pointerZ + offsetZ;
+                    if (redressZ >= 0 && redressZ < maxDiameter) {
+                        for (rowX = 0; rowX < rowStack; rowX++)
+                            viewData[(pointerZ << rowStackOffset) | rowX] = viewData[(redressZ << rowStackOffset) | rowX];
+                    } else {
+                        for (rowX = 0; rowX < rowStack; rowX++)
+                            viewData[(pointerZ << rowStackOffset) | rowX] = 0;
+                    }
+                }
+            } else if (offsetZ > 0) {
+                int redressZ;
+                int rowX;
+                for (pointerZ = 0; pointerZ < maxDiameter; pointerZ++) {
+                    redressZ = pointerZ + offsetZ;
+                    if (redressZ >= 0 && redressZ < maxDiameter) {
+                        for (rowX = 0; rowX < rowStack; rowX++)
+                            viewData[(pointerZ << rowStackOffset) | rowX] = viewData[(redressZ << rowStackOffset) | rowX];
+                    } else {
+                        for (rowX = 0; rowX < rowStack; rowX++)
+                            viewData[(pointerZ << rowStackOffset) | rowX] = 0;
+                    }
+                }
+            }
+
+            if (moveX != centerX || moveZ != centerZ) {
+                completedDistance.addAndGet(-Math.max(Math.abs(centerX - moveX), Math.abs(centerZ - moveZ)));
+            }
+            centerX = moveX;
+            centerZ = moveZ;
+
+            return removeKeys;
+        } else {
+            return new ArrayList<>(0);
+        }
+    }
+
+
+    /**
+     * 取得下一個應該要處裡的區塊
+     *
+     * @return positionKey, 若沒有需要處裡的區塊, 則回傳 null
+     */
+    public Long get() {
+        int viewDistance = Math.min(maxRadius, extendDistance + 1);
+        int edgeStepCount = 0;  // 每個邊, 移動幾次換方向
+        int readX;
+        int readZ;
+        int pointerX;
+        int pointerZ;
+        int stepCount;
+        int chunkX;
+        int chunkZ;
+        boolean notMiss = true;
+
+        for (int distance = 0; distance <= maxRadius && distance <= viewDistance; distance++) {
+            if (distance > completedDistance.get()) {
+                // 總共有 4 次方向
+                readX = distance;
+                readZ = distance;
+                pointerX = maxRadius + distance;
+                pointerZ = maxRadius + distance;
+
+                // Z--
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerZ--;
+                    readZ--;
+                }
+                // X--
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerX--;
+                    readX--;
+                }
+                // Z++
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerZ++;
+                    readZ++;
+                }
+                // X++
+                for (stepCount = 0; stepCount < edgeStepCount; ++stepCount) {
+                    chunkX = centerX - readX;
+                    chunkZ = centerZ - readZ;
+                    if (!viewShape.isInsideEdge(centerX, centerZ, chunkX, chunkZ, serverDistance) && viewShape.isInside(centerX, centerZ, chunkX, chunkZ, viewDistance)) {
+                        if (isWaitSafe(pointerX, pointerZ)) {
+                            markSendSafe(pointerX, pointerZ);
+                            return getPositionKey(chunkX, chunkZ);
+                        } else {
+                            notMiss = false;
+                        }
+                    }
+
+                    pointerX++;
+                    readX++;
+                }
+
+                if (notMiss) {
+                    completedDistance.set(distance);
+                }
+            }
+
+            // 下一次循環
+            edgeStepCount += 2;
+        }
+        return null;
+    }
+
+
+    private int blockToChunk(double location) {
+        return blockToChunk((int) location);
+    }
+
+    private int blockToChunk(int blockLocation) {
+        return blockLocation >> 4;
+    }
+
+
+    public boolean inPosition(int positionX, int positionZ) {
+        int pointerX = maxRadius + (centerX - positionX);
+        int pointerZ = maxRadius + (centerZ - positionZ);
+        int viewDistance = Math.min(maxRadius, extendDistance);
+        return pointerX <= maxRadius + viewDistance && pointerX >= maxRadius - viewDistance && pointerZ <= maxRadius + viewDistance && pointerZ >= maxRadius - viewDistance;
+    }
+
+
+    public boolean isWaitPosition(long positionKey) {
+        return isWaitPosition(getX(positionKey), getZ(positionKey));
+    }
+
+    public boolean isWaitPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = maxRadius + (centerX - positionX);
+        int pointerZ = maxRadius + (centerZ - positionZ);
+        return pointerX >= 0 && pointerX < maxDiameter && pointerZ >= 0 && pointerZ < maxDiameter && isWaitSafe(pointerX, pointerZ);
+    }
+
+    public boolean isSendPosition(long positionKey) {
+        return isSendPosition(getX(positionKey), getZ(positionKey));
+    }
+
+    public boolean isSendPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = maxRadius + (centerX - positionX);
+        int pointerZ = maxRadius + (centerZ - positionZ);
+        return pointerX >= 0 && pointerX < maxDiameter && pointerZ >= 0 && pointerZ < maxDiameter && isSendSafe(pointerX, pointerZ);
+    }
+
+    public void markWaitPosition(long positionKey) {
+        markWaitPosition(getX(positionKey), getZ(positionKey));
+    }
+
+    public void markWaitPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = maxRadius + (centerX - positionX);
+        int pointerZ = maxRadius + (centerZ - positionZ);
+        if (pointerX >= 0 && pointerX < maxDiameter && pointerZ >= 0 && pointerZ < maxDiameter)
+            markWaitSafe(pointerX, pointerZ);
+    }
+
+    public void markSendPosition(long positionKey) {
+        markSendPosition(getX(positionKey), getZ(positionKey));
+    }
+
+    public void markSendPosition(int positionX, int positionZ) {
+        // 上一個紀錄的區塊位置 (中心點)
+        int pointerX = maxRadius + (centerX - positionX);
+        int pointerZ = maxRadius + (centerZ - positionZ);
+        if (pointerX >= 0 && pointerX < maxDiameter && pointerZ >= 0 && pointerZ < maxDiameter)
+            markSendSafe(pointerX, pointerZ);
+    }
+
+
+    private int toViewPointer(int pointerX, int pointerZ) {
+        return pointerZ << rowStackOffset | pointerX >>> 6;
+    }
+
+    public boolean isWaitSafe(int pointerX, int pointerZ) {
+        return !isSendSafe(pointerX, pointerZ);
+    }
+
+    public boolean isSendSafe(int pointerX, int pointerZ) {
+        return (viewData[toViewPointer(pointerX, pointerZ)] << (pointerX & 0b111111) & 0b1000000000000000000000000000000000000000000000000000000000000000L) == 0b1000000000000000000000000000000000000000000000000000000000000000L;
+    }
+
+
+    public boolean markWaitSafe(int pointerX, int pointerZ) {
+        if (isSendSafe(pointerX, pointerZ)) {
+            viewData[toViewPointer(pointerX, pointerZ)] ^= (0b1000000000000000000000000000000000000000000000000000000000000000L >>> (pointerX & 0b111111));
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void markSendSafe(int pointerX, int pointerZ) {
+        viewData[toViewPointer(pointerX, pointerZ)] |= (0b1000000000000000000000000000000000000000000000000000000000000000L >>> (pointerX & 0b111111));
+    }
+
+
+    /**
+     * @param range 範圍外的區塊標記為等待中
+     */
+    public void markOutsideWait(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < maxDiameter; ++pointerX) {
+            for (pointerZ = 0; pointerZ < maxDiameter; ++pointerZ) {
+                chunkX = centerX + pointerX - maxRadius;
+                chunkZ = centerZ + pointerZ - maxRadius;
+                if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markWaitSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+    /**
+     * @param range 範圍外的區塊標記為以發送
+     */
+    public void markOutsideSend(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < maxDiameter; ++pointerX) {
+            for (pointerZ = 0; pointerZ < maxDiameter; ++pointerZ) {
+                chunkX = centerX + pointerX - maxRadius;
+                chunkZ = centerZ + pointerZ - maxRadius;
+                if (!viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markSendSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+
+    /**
+     * @param range 範圍內的區塊標記為等待中
+     */
+    public void markInsideWait(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < maxDiameter; ++pointerX) {
+            for (pointerZ = 0; pointerZ < maxDiameter; ++pointerZ) {
+                chunkX = centerX + pointerX - maxRadius;
+                chunkZ = centerZ + pointerZ - maxRadius;
+                if (viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markWaitSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+    /**
+     * @param range 範圍內的區塊標記為以發送
+     */
+    public void markInsideSend(int range) {
+        // 確保只能是正數
+        if (range < 0)
+            range = Math.abs(range);
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < maxDiameter; ++pointerX) {
+            for (pointerZ = 0; pointerZ < maxDiameter; ++pointerZ) {
+                chunkX = centerX + pointerX - maxRadius;
+                chunkZ = centerZ + pointerZ - maxRadius;
+                if (viewShape.isInside(centerX, centerZ, chunkX, chunkZ, range))
+                    markSendSafe(pointerX, pointerZ);
+            }
+        }
+    }
+
+
+    public List<Long> getAll() {
+        List<Long> chunkList = new ArrayList<>();
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < maxDiameter; ++pointerX) {
+            for (pointerZ = 0; pointerZ < maxDiameter; ++pointerZ) {
+                chunkX = centerX + pointerX - maxRadius;
+                chunkZ = centerZ + pointerZ - maxRadius;
+                chunkList.add(getPositionKey(chunkX, chunkZ));
+            }
+        }
+        return chunkList;
+    }
+
+    public List<Long> getAllNotServer() {
+        List<Long> chunkList = new ArrayList<>();
+        int pointerX;
+        int pointerZ;
+        int chunkX;
+        int chunkZ;
+        for (pointerX = 0; pointerX < maxDiameter; ++pointerX) {
+            for (pointerZ = 0; pointerZ < maxDiameter; ++pointerZ) {
+                chunkX = centerX + pointerX - maxRadius;
+                chunkZ = centerZ + pointerZ - maxRadius;
+                if (isSendSafe(pointerX, pointerZ) && !viewShape.isInside(centerX, centerZ, chunkX, chunkZ, serverDistance))
+                    chunkList.add(getPositionKey(chunkX, chunkZ));
+            }
+        }
+        return chunkList;
+    }
+
+
+    public void clear() {
+        System.arraycopy(new long[viewData.length], 0, viewData, 0, viewData.length);
+        completedDistance.set(-1);
+    }
+
+
+    public void debug(CommandSender sender) {
+        StringBuilder builder = new StringBuilder();
+        builder.append("LongXInfinitelyViewMap:\n");
+        for (int index = 0; index < viewData.length; ++index) {
+            if (index != 0 && index % rowStack == 0)
+                builder.append('\n');
+            long value = viewData[index];
+            for (int read = 63; read >= 0; read--)
+                builder.append((value >> read & 1) == 1 ? '■' : '□');
+        }
+        sender.sendMessage(builder.toString());
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewMap.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0ca56b48bddf8bc3ecdce08f42956f2e46ad961
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewMap.java
@@ -0,0 +1,142 @@
+package com.github.ipecter.fusion.zerochunk.data.viewmap;
+
+import org.bukkit.Location;
+import org.bukkit.command.CommandSender;
+
+import java.util.List;
+
+public abstract class ViewMap {
+    public final ViewShape viewShape;
+    public int extendDistance = 1;
+    public int serverDistance = 1;
+    protected int centerX = 0;
+    protected int centerZ = 0;
+
+    protected ViewMap(ViewShape viewShape) {
+        this.viewShape = viewShape;
+    }
+
+
+    public abstract List<Long> movePosition(Location location);
+
+    /**
+     * 移動到區塊位置 (中心點)
+     *
+     * @param moveX 區塊座標X
+     * @param moveZ 區塊座標Z
+     * @return 如果有區塊被移除, 則會集中回傳在這
+     */
+    public abstract List<Long> movePosition(int moveX, int moveZ);
+
+
+    /**
+     * 取得下一個應該要處裡的區塊
+     *
+     * @return positionKey, 若沒有需要處裡的區塊, 則回傳 null
+     */
+    public abstract Long get();
+
+    public int getCenterX() {
+        return centerX;
+    }
+
+    public int getCenterZ() {
+        return centerZ;
+    }
+
+    public final void setCenter(Location location) {
+        setCenter(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+
+    public final void setCenter(int positionX, int positionZ) {
+        setCenterX(positionX);
+        setCenterZ(positionZ);
+    }
+
+    public void setCenterX(int centerX) {
+        this.centerX = centerX;
+    }
+
+    public void setCenterZ(int centerZ) {
+        this.centerZ = centerZ;
+    }
+
+
+    public static int getX(long positionKey) {
+        return (int) (positionKey);
+    }
+
+    public static int getZ(long positionKey) {
+        return (int) (positionKey >> 32);
+    }
+
+    public static long getPositionKey(int x, int z) {
+        return ((long) z << 32) & 0b1111111111111111111111111111111100000000000000000000000000000000L | x & 0b0000000000000000000000000000000011111111111111111111111111111111L;
+    }
+
+
+    public abstract boolean inPosition(int positionX, int positionZ);
+
+
+    public abstract boolean isWaitPosition(long positionKey);
+
+    public abstract boolean isWaitPosition(int positionX, int positionZ);
+
+
+    public abstract boolean isSendPosition(long positionKey);
+
+    public abstract boolean isSendPosition(int positionX, int positionZ);
+
+
+    public abstract void markWaitPosition(long positionKey);
+
+    public abstract void markWaitPosition(int positionX, int positionZ);
+
+
+    public abstract void markSendPosition(long positionKey);
+
+    public abstract void markSendPosition(int positionX, int positionZ);
+
+
+    /**
+     * @param range 範圍外的區塊標記為等待中
+     */
+    public abstract void markOutsideWait(int range);
+
+    /**
+     * @param range 範圍外的區塊標記為以發送
+     */
+    public abstract void markOutsideSend(int range);
+
+
+    /**
+     * @param range 範圍內的區塊標記為等待中
+     */
+    public abstract void markInsideWait(int range);
+
+    /**
+     * @param range 範圍內的區塊標記為以發送
+     */
+    public abstract void markInsideSend(int range);
+
+
+    public abstract List<Long> getAll();
+
+    public abstract List<Long> getAllNotServer();
+
+
+    public abstract boolean isWaitSafe(int pointerX, int pointerZ);
+
+    public abstract boolean isSendSafe(int pointerX, int pointerZ);
+
+
+    public abstract boolean markWaitSafe(int pointerX, int pointerZ);
+
+    public abstract void markSendSafe(int pointerX, int pointerZ);
+
+
+    public abstract void clear();
+
+
+    public abstract void debug(CommandSender sender);
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewMapMode.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewMapMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..a61033b0fd16876eac587a69f4e6affad4449b67
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewMapMode.java
@@ -0,0 +1,28 @@
+package com.github.ipecter.fusion.zerochunk.data.viewmap;
+
+import java.util.function.Function;
+
+public enum ViewMapMode {
+    X15(IntX15ViewMap::new, 15),
+    X31(LongX31ViewMap::new, 31),
+    X63((viewShape) -> new LongXInfinitelyViewMap(viewShape, 2), 63),
+    X127((viewShape) -> new LongXInfinitelyViewMap(viewShape, 4), 127),
+    X383((viewShape) -> new LongXInfinitelyViewMap(viewShape, 6), 383),
+    ;
+
+    private final int extend;
+    private final Function<ViewShape, ViewMap> create;
+
+    ViewMapMode(Function<ViewShape, ViewMap> create, int extend) {
+        this.extend = extend;
+        this.create = create;
+    }
+
+    public ViewMap createMap(ViewShape viewShape) {
+        return create.apply(viewShape);
+    }
+
+    public int getExtend() {
+        return extend;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewShape.java b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewShape.java
new file mode 100644
index 0000000000000000000000000000000000000000..b732a884859f4a5feafb61adfc829ae19a6638ce
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/data/viewmap/ViewShape.java
@@ -0,0 +1,57 @@
+package com.github.ipecter.fusion.zerochunk.data.viewmap;
+
+/**
+ * 視圖形狀
+ */
+public enum ViewShape {
+    /** 方形 */
+    SQUARE((int aX, int aZ, int bX, int bZ, int viewDistance) -> {
+        int minX = bX - viewDistance;
+        int minZ = bZ - viewDistance;
+        int maxX = bX + viewDistance;
+        int maxZ = bZ + viewDistance;
+        return aX >= minX && aZ >= minZ && aX <= maxX && aZ <= maxZ;
+    }),
+    /** 圓形 */
+    ROUND((int aX, int aZ, int bX, int bZ, int viewDistance) -> {
+        int viewDiameter = viewDistance * viewDistance + viewDistance;
+        int distanceX = aX - bX;
+        int distanceZ = aZ - bZ;
+        int distance = distanceX * distanceX + distanceZ * distanceZ;
+        return distance <= viewDiameter;
+    }, (int aX, int aZ, int bX, int bZ, int viewDistance) -> {
+        JudgeInside inside = (int _aX, int _aZ, int _bX, int _bZ, int viewDiameter) -> {
+            int distanceX = _aX - _bX;
+            int distanceZ = _aZ - _bZ;
+            int distance = distanceX * distanceX + distanceZ * distanceZ;
+            return distance <= viewDiameter;
+        };
+        int viewDiameter = viewDistance * viewDistance + viewDistance;
+        return inside.test(aX, aZ, bX, bZ, viewDiameter) && !(!inside.test(aX + 1, aZ, bX, bZ, viewDiameter) || !inside.test(aX - 1, aZ, bX, bZ, viewDiameter) || !inside.test(aX, aZ + 1, bX, bZ, viewDiameter) || !inside.test(aX, aZ - 1, bX, bZ, viewDiameter));
+    }),
+    ;
+
+    /**
+     * 許可計算
+     */
+    interface JudgeInside {
+        boolean test(int aX, int aZ, int bX, int bZ, int viewDistance);
+    }
+    private final JudgeInside judgeInside;
+    private final JudgeInside judgeInsideEdge;
+
+    ViewShape(JudgeInside judgeInside) {
+        this(judgeInside, judgeInside);
+    }
+    ViewShape(JudgeInside judgeInside, JudgeInside judgeInsideEdge) {
+        this.judgeInside        = judgeInside;
+        this.judgeInsideEdge    = judgeInsideEdge;
+    }
+
+    public boolean isInside(int aX, int aZ, int bX, int bZ, int viewDistance) {
+        return judgeInside.test(aX, aZ, bX, bZ, viewDistance);
+    }
+    public boolean isInsideEdge(int aX, int aZ, int bX, int bZ, int viewDistance) {
+        return judgeInsideEdge.test(aX, aZ, bX, bZ, viewDistance);
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/ExtendChunkEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/ExtendChunkEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..70530f4be2e520335da4b2170472af9fd6e357cc
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/ExtendChunkEvent.java
@@ -0,0 +1,18 @@
+package com.github.ipecter.fusion.zerochunk.event;
+
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.Bukkit;
+import org.bukkit.event.Event;
+
+public abstract class ExtendChunkEvent extends Event {
+    private final PlayerView view;
+
+    public ExtendChunkEvent(PlayerView view) {
+        super(!Bukkit.isPrimaryThread());
+        this.view = view;
+    }
+
+    public PlayerView getView() {
+        return view;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerCheckViewDistanceEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerCheckViewDistanceEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b6b180459e3743f73346bf85edc1bdc3772b879a
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerCheckViewDistanceEvent.java
@@ -0,0 +1,51 @@
+package com.github.ipecter.fusion.zerochunk.event;
+
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.event.HandlerList;
+
+public final class PlayerCheckViewDistanceEvent extends ExtendChunkEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    private final int serverDistance;
+    private final int clientDistance;
+    private final int maxDistance;
+    private Integer forciblyDistance;
+
+
+    public PlayerCheckViewDistanceEvent(PlayerView view, int serverDistance, int clientDistance, int maxDistance) {
+        super(view);
+        this.serverDistance = serverDistance;
+        this.clientDistance = clientDistance;
+        this.maxDistance = maxDistance;
+    }
+
+
+    public int getClientDistance() {
+        return clientDistance;
+    }
+
+    public int getMaxDistance() {
+        return maxDistance;
+    }
+
+    public int getServerDistance() {
+        return serverDistance;
+    }
+
+    public Integer getForciblyDistance() {
+        return forciblyDistance;
+    }
+
+    public void setForciblyDistance(Integer forciblyDistance) {
+        this.forciblyDistance = forciblyDistance;
+    }
+
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerInitViewEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerInitViewEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..7013a52606a5aae23d89b95b5f847bc4fd48c47f
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerInitViewEvent.java
@@ -0,0 +1,22 @@
+package com.github.ipecter.fusion.zerochunk.event;
+
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.event.HandlerList;
+
+public final class PlayerInitViewEvent extends ExtendChunkEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+
+    public PlayerInitViewEvent(PlayerView view) {
+        super(view);
+    }
+
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendExtendChunkEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendExtendChunkEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e713bd23b554f7c5194ba3dd552830cfb755ce3
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendExtendChunkEvent.java
@@ -0,0 +1,47 @@
+package com.github.ipecter.fusion.zerochunk.event;
+
+import com.github.ipecter.fusion.zerochunk.branch.BranchChunk;
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.World;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+public final class PlayerSendExtendChunkEvent extends ExtendChunkEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+
+    private boolean cancel = false;
+    private final BranchChunk chunk;
+    private final World world;
+
+    public PlayerSendExtendChunkEvent(PlayerView view, BranchChunk chunk, World world) {
+        super(view);
+        this.chunk = chunk;
+        this.world = world;
+    }
+
+
+    public BranchChunk getChunk() {
+        return chunk;
+    }
+
+    public World getWorld() {
+        return world;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendUnloadChunkEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendUnloadChunkEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ab98aa5a6c1700b1f1c56e8b15c939d15301524
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendUnloadChunkEvent.java
@@ -0,0 +1,49 @@
+package com.github.ipecter.fusion.zerochunk.event;
+
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * 發送區塊卸除給玩家時
+ */
+public final class PlayerSendUnloadChunkEvent extends ExtendChunkEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+
+    private boolean cancel = false;
+    private final int chunkX;
+    private final int chunkZ;
+
+
+    public PlayerSendUnloadChunkEvent(PlayerView view, int chunkX, int chunkZ) {
+        super(view);
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+    }
+
+
+    public int getChunkX() {
+        return chunkX;
+    }
+
+    public int getChunkZ() {
+        return chunkZ;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendViewDistanceEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendViewDistanceEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ff4ed34dc1a02f973cf4f48f660325c372b30d1
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerSendViewDistanceEvent.java
@@ -0,0 +1,44 @@
+package com.github.ipecter.fusion.zerochunk.event;
+
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+public final class PlayerSendViewDistanceEvent extends ExtendChunkEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+
+    private boolean cancel = false;
+    private int distance;
+
+
+    public PlayerSendViewDistanceEvent(PlayerView view, int distance) {
+        super(view);
+        this.distance = distance;
+    }
+
+
+    public int getDistance() {
+        return distance;
+    }
+
+    public void setDistance(int distance) {
+        this.distance = distance;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerViewMarkSendChunkEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerViewMarkSendChunkEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b032906fd14e0823a8fec8922cb0a54a639a204
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerViewMarkSendChunkEvent.java
@@ -0,0 +1,46 @@
+package com.github.ipecter.fusion.zerochunk.event;
+
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+public final class PlayerViewMarkSendChunkEvent extends ExtendChunkEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+
+    private boolean cancel = false;
+    private final int chunkX;
+    private final int chunkZ;
+
+
+    public PlayerViewMarkSendChunkEvent(PlayerView view, int chunkX, int chunkZ) {
+        super(view);
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+    }
+
+
+    public int getChunkX() {
+        return chunkX;
+    }
+
+    public int getChunkZ() {
+        return chunkZ;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerViewMarkWaitChunkEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerViewMarkWaitChunkEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..08e97a3398be0c012a80aef7fa2a21ca852979cc
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/PlayerViewMarkWaitChunkEvent.java
@@ -0,0 +1,46 @@
+package com.github.ipecter.fusion.zerochunk.event;
+
+import com.github.ipecter.fusion.zerochunk.data.PlayerView;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+public final class PlayerViewMarkWaitChunkEvent extends ExtendChunkEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+
+    private boolean cancel = false;
+    private final int chunkX;
+    private final int chunkZ;
+
+
+    public PlayerViewMarkWaitChunkEvent(PlayerView view, int chunkX, int chunkZ) {
+        super(view);
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+    }
+
+
+    public int getChunkX() {
+        return chunkX;
+    }
+
+    public int getChunkZ() {
+        return chunkZ;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..8edd03116cb422ef05b48e05a4894d93d39b6a21
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketEvent.java
@@ -0,0 +1,28 @@
+package com.github.ipecter.fusion.zerochunk.event.packet;
+
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+
+public abstract class PacketEvent extends Event implements Cancellable {
+    private final Player player;
+    private boolean cancel = false;
+
+    public PacketEvent(Player player) {
+        super(!Bukkit.isPrimaryThread());
+        this.player = player;
+    }
+
+    public final boolean isCancelled() {
+        return cancel;
+    }
+
+    public final void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    public final Player getPlayer() {
+        return player;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketKeepAliveEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketKeepAliveEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..af4930ea17d7f12f4dbb39e248bf8ad368f50c8d
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketKeepAliveEvent.java
@@ -0,0 +1,27 @@
+package com.github.ipecter.fusion.zerochunk.event.packet;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+
+public final class PacketKeepAliveEvent extends PacketEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    private final long id;
+
+    public PacketKeepAliveEvent(Player player, long id) {
+        super(player);
+        this.id = id;
+    }
+
+    public long getId() {
+        return id;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketMapChunkEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketMapChunkEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..c43d283d96b2e6da76c30b3c5e3041dbc78d1602
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketMapChunkEvent.java
@@ -0,0 +1,33 @@
+package com.github.ipecter.fusion.zerochunk.event.packet;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+
+public final class PacketMapChunkEvent extends PacketEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    private final int chunkX;
+    private final int chunkZ;
+
+    public PacketMapChunkEvent(Player player, int chunkX, int chunkZ) {
+        super(player);
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+    }
+
+    public int getChunkX() {
+        return chunkX;
+    }
+
+    public int getChunkZ() {
+        return chunkZ;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketUnloadChunkEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketUnloadChunkEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..0ecd4c58108c7cfd33409731ef65f4c38977d634
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketUnloadChunkEvent.java
@@ -0,0 +1,33 @@
+package com.github.ipecter.fusion.zerochunk.event.packet;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+
+public final class PacketUnloadChunkEvent extends PacketEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    private final int chunkX;
+    private final int chunkZ;
+
+    public PacketUnloadChunkEvent(Player player, int chunkX, int chunkZ) {
+        super(player);
+        this.chunkX = chunkX;
+        this.chunkZ = chunkZ;
+    }
+
+    public int getChunkX() {
+        return chunkX;
+    }
+
+    public int getChunkZ() {
+        return chunkZ;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketViewDistanceEvent.java b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketViewDistanceEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..89ecc72c7a68715c11c4103956bfd5d711435d51
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/zerochunk/event/packet/PacketViewDistanceEvent.java
@@ -0,0 +1,28 @@
+package com.github.ipecter.fusion.zerochunk.event.packet;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+
+public final class PacketViewDistanceEvent extends PacketEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    private final int viewDistance;
+
+    public PacketViewDistanceEvent(Player player, int viewDistance) {
+        super(player);
+        this.viewDistance = viewDistance;
+    }
+
+    public int getViewDistance() {
+        return viewDistance;
+    }
+
+}
\ No newline at end of file
