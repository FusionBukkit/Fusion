From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kugge <sofiane.djerbi38@gmail.com>
Date: Sun, 5 Feb 2023 02:30:01 +0100
Subject: [PATCH] Xymb Linear RegionFile Format


diff --git a/build.gradle.kts b/build.gradle.kts
index 392a30619460f2b0e6dc14394ef564d5d9ca4769..f15cfa0f2bdf33178ff2a7c075ab2758b169c898 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -13,6 +13,10 @@ dependencies {
         exclude("io.papermc.paper", "paper-api")
     }
     // Pufferfish end
+    // Fusion start - Linear format
+    implementation("com.github.luben:zstd-jni:1.5.2-5")
+    implementation("org.lz4:lz4-java:1.8.0")
+    // Fusion end - Linear format
     // Paper start
     implementation("org.jline:jline-terminal-jansi:3.21.0")
     implementation("net.minecrell:terminalconsoleappender:1.3.0")
diff --git a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
index f2c27e0ac65be4b75c1d86ef6fd45fdb538d96ac..1dabeaeede933e370fbb450ff8ea5907d410a574 100644
--- a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
+++ b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
@@ -1,10 +1,11 @@
 package com.destroystokyo.paper.io;
 
+import com.github.ipecter.fusion.region.AbstractRegionFile; // Fusion
 import com.mojang.logging.LogUtils;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.chunk.storage.RegionFile;
+//import net.minecraft.world.level.chunk.storage.RegionFile; // Fusion
 import org.slf4j.Logger;
 
 import java.io.IOException;
@@ -314,8 +315,8 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         public abstract void writeData(final int x, final int z, final CompoundTag compound) throws IOException;
         public abstract CompoundTag readData(final int x, final int z) throws IOException;
 
-        public abstract <T> T computeForRegionFile(final int chunkX, final int chunkZ, final Function<RegionFile, T> function);
-        public abstract <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<RegionFile, T> function);
+        public abstract <T> T computeForRegionFile(final int chunkX, final int chunkZ, final Function<AbstractRegionFile, T> function); // Fusion
+        public abstract <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<AbstractRegionFile, T> function); // Fusion
 
         public static final class InProgressWrite {
             public long writeCounter;
diff --git a/src/main/java/com/github/ipecter/fusion/FusionConfig.java b/src/main/java/com/github/ipecter/fusion/FusionConfig.java
index 453e23d8e52fac73d2dcc0473e7123ce562da96c..6f316c041c47b54eab3efb927eaf0a47fb2c9909 100644
--- a/src/main/java/com/github/ipecter/fusion/FusionConfig.java
+++ b/src/main/java/com/github/ipecter/fusion/FusionConfig.java
@@ -314,7 +314,7 @@ public class FusionConfig {
     private static void smoothBootConfigSetup() {
     }
 
-    public static List<String> regionFormatList = Arrays.asList("ANVIL");
+    public static List<String> regionFormatList = Arrays.asList("ANVIL", "LINEAR");
     public static String regionFormatName = "ANVIL";
 
     private static void regionFormatConfig() {
diff --git a/src/main/java/com/github/ipecter/fusion/region/AbstractRegionFile.java b/src/main/java/com/github/ipecter/fusion/region/AbstractRegionFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c5befcf9a7d93bb8674b3f8f8e0c45a821b07cd
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/region/AbstractRegionFile.java
@@ -0,0 +1,33 @@
+package com.github.ipecter.fusion.region;
+
+import java.io.IOException;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.nio.ByteBuffer;
+import java.nio.file.Path;
+import java.util.concurrent.locks.ReentrantLock;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkStatus;
+
+public interface AbstractRegionFile {
+    boolean doesChunkExist(ChunkPos pos) throws Exception;
+    void flush() throws IOException;
+    void setStatus(int x, int z, ChunkStatus status);
+    void clear(ChunkPos pos) throws IOException;
+    boolean hasChunk(ChunkPos pos);
+    void close() throws IOException;
+
+    DataOutputStream getChunkDataOutputStream(ChunkPos pos) throws IOException;
+    DataInputStream getChunkDataInputStream(ChunkPos pos) throws IOException;
+    ChunkStatus getStatusIfCached(int x, int z);
+
+    Path getRegionFile();
+    ReentrantLock getFileLock();
+
+    void setOversized(int x, int z, boolean b) throws IOException;
+    CompoundTag getOversizedData(int x, int z) throws IOException;
+    boolean isOversized(int x, int z);
+    boolean recalculateHeader() throws IOException;
+}
diff --git a/src/main/java/com/github/ipecter/fusion/region/AbstractRegionFileFactory.java b/src/main/java/com/github/ipecter/fusion/region/AbstractRegionFileFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..93ac01b9b85ad18927856e1b8291d04054e54110
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/region/AbstractRegionFileFactory.java
@@ -0,0 +1,39 @@
+package com.github.ipecter.fusion.region;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+
+import com.github.ipecter.fusion.region.LinearRegionFile;
+import com.github.ipecter.fusion.region.AbstractRegionFile;
+import net.minecraft.world.level.chunk.storage.RegionFile;
+import net.minecraft.world.level.chunk.storage.RegionFileVersion;
+
+public class AbstractRegionFileFactory {
+    public static AbstractRegionFile getAbstractRegionFile(Path file, Path directory, boolean dsync) throws IOException {
+        return getAbstractRegionFile(file, directory, RegionFileVersion.VERSION_DEFLATE, dsync);
+    }
+
+    public static AbstractRegionFile getAbstractRegionFile(Path file, Path directory, boolean dsync, boolean canRecalcHeader) throws IOException {
+        return getAbstractRegionFile(file, directory, RegionFileVersion.VERSION_DEFLATE, dsync, canRecalcHeader);
+    }
+
+    public static AbstractRegionFile getAbstractRegionFile(File file, File directory, boolean dsync) throws IOException {
+        return getAbstractRegionFile(file.toPath(), directory.toPath(), RegionFileVersion.VERSION_DEFLATE, dsync);
+    }
+    public static AbstractRegionFile getAbstractRegionFile(File file, File directory, boolean dsync, boolean canRecalcHeader) throws IOException {
+        return getAbstractRegionFile(file.toPath(), directory.toPath(), RegionFileVersion.VERSION_DEFLATE, dsync, canRecalcHeader);
+    }
+
+    public static AbstractRegionFile getAbstractRegionFile(Path file, Path directory, RegionFileVersion outputChunkStreamVersion, boolean dsync) throws IOException {
+        return getAbstractRegionFile(file, directory, outputChunkStreamVersion, dsync, false);
+    }
+
+    public static AbstractRegionFile getAbstractRegionFile(Path file, Path directory, RegionFileVersion outputChunkStreamVersion, boolean dsync, boolean canRecalcHeader) throws IOException {
+        if  (com.github.ipecter.fusion.FusionConfig.regionFormatName.equals("LINEAR")) {
+            return new LinearRegionFile(file, directory, outputChunkStreamVersion, dsync, canRecalcHeader);
+        } else {
+            return new RegionFile(file, directory, outputChunkStreamVersion, dsync, canRecalcHeader);
+        }
+    }
+}
diff --git a/src/main/java/com/github/ipecter/fusion/region/LinearRegionFile.java b/src/main/java/com/github/ipecter/fusion/region/LinearRegionFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..0853d9815b25e2b0ba3da711220ec13ab87a2c1b
--- /dev/null
+++ b/src/main/java/com/github/ipecter/fusion/region/LinearRegionFile.java
@@ -0,0 +1,392 @@
+package com.github.ipecter.fusion.region;
+
+import com.github.ipecter.fusion.region.AbstractRegionFile;
+import com.google.common.annotations.VisibleForTesting;
+import com.mojang.logging.LogUtils;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
+import java.nio.file.StandardOpenOption;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.zip.InflaterInputStream;
+import java.util.ArrayList;
+import com.github.luben.zstd.ZstdOutputStream;
+import com.github.luben.zstd.ZstdInputStream;
+import net.jpountz.lz4.LZ4Factory;
+import net.jpountz.lz4.LZ4Compressor;
+import net.jpountz.lz4.LZ4FastDecompressor;
+import net.jpountz.xxhash.XXHashFactory;
+
+import javax.annotation.Nullable;
+import net.minecraft.Util;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.storage.RegionFileVersion;
+
+import org.slf4j.Logger;
+
+public class LinearRegionFile extends Thread implements AbstractRegionFile {
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private final byte[][] buffer = new byte[32*32][];
+    private final int[] bufferUncompressedSize = new int[32*32];
+
+    private final ChunkStatus[] statuses = new ChunkStatus[32 * 32];
+    private boolean markedToSave = false;
+    private Object markedToSaveLock = new Object();
+    private boolean close = false;
+    public Path regionFile;
+    public final ReentrantLock fileLock = new ReentrantLock(true);
+    final byte COMPRESSION_LEVEL = 1;
+
+    public Path getRegionFile() {
+        return this.regionFile;
+    }
+
+    public ReentrantLock getFileLock() {
+        return this.fileLock;
+    }
+
+    public LinearRegionFile(Path file, Path directory, boolean dsync) throws IOException {
+        this(file, directory, RegionFileVersion.VERSION_DEFLATE, dsync);
+    }
+
+    public LinearRegionFile(Path file, Path directory, boolean dsync, boolean canRecalcHeader) throws IOException {
+        this(file, directory, RegionFileVersion.VERSION_DEFLATE, dsync, canRecalcHeader);
+    }
+
+    public LinearRegionFile(File file, File directory, boolean dsync) throws IOException {
+        this(file.toPath(), directory.toPath(), RegionFileVersion.VERSION_DEFLATE, dsync);
+    }
+    public LinearRegionFile(File file, File directory, boolean dsync, boolean canRecalcHeader) throws IOException {
+        this(file.toPath(), directory.toPath(), RegionFileVersion.VERSION_DEFLATE, dsync, canRecalcHeader);
+    }
+
+    public LinearRegionFile(Path file, Path directory, RegionFileVersion outputChunkStreamVersion, boolean dsync) throws IOException {
+        this(file, directory, outputChunkStreamVersion, dsync, false);
+    }
+
+    public LinearRegionFile(Path file, Path directory, RegionFileVersion outputChunkStreamVersion, boolean dsync, boolean canRecalcHeader) throws IOException {
+        this.regionFile = file;
+        File regionFile = new File(this.regionFile.toString());
+
+        LZ4Compressor compressor = LZ4Factory.fastestInstance().fastCompressor();
+        LZ4FastDecompressor decompressor = LZ4Factory.fastestInstance().fastDecompressor();
+
+        for (int i = 0 ; i < 32 * 32 ; i++)
+            this.bufferUncompressedSize[i] = 0;
+
+        if(regionFile.canRead()) {
+            long start = System.nanoTime();
+
+            long fileLength = file.toFile().length();
+            FileInputStream fileStream = new FileInputStream(regionFile);
+            DataInputStream rawDataStream = new DataInputStream(fileStream);
+
+            long SUPERBLOCK = -4323716122432332390L;
+            byte VERSION = 1;
+            int HEADER_SIZE = 32;
+            int FOOTER_SIZE = 8;
+
+            long superBlock = rawDataStream.readLong();
+
+            if (superBlock != SUPERBLOCK) {
+                System.out.println(file.toString());
+                System.out.println("SUPERBLOCK INVALID!");
+                return;
+            }
+
+            byte version = rawDataStream.readByte();
+
+            if (version != VERSION) {
+                System.out.println(file.toString());
+                System.out.println("VERSION INVALID!");
+                return;
+            }
+
+            long newestTimestamp = rawDataStream.readLong();
+            byte compressionLevel = rawDataStream.readByte();
+            short chunkCount = rawDataStream.readShort();
+            int dataCount = rawDataStream.readInt();
+
+            if (fileLength != HEADER_SIZE + dataCount + FOOTER_SIZE) {
+                throw new IOException("File length invalid " + this.regionFile + " " + String.valueOf(fileLength) + " " + String.valueOf(HEADER_SIZE + dataCount + FOOTER_SIZE));
+            }
+
+            long dataHash = rawDataStream.readLong();
+            byte[] rawCompressed = new byte[dataCount];
+
+            rawDataStream.readFully(rawCompressed, 0, dataCount);
+
+            superBlock = rawDataStream.readLong();
+
+            if (superBlock != SUPERBLOCK) {
+                throw new IOException("Footer superblock invalid " + this.regionFile);
+            }
+
+            DataInputStream dataStream = new DataInputStream(new ZstdInputStream(new ByteArrayInputStream(rawCompressed)));
+
+            int completeDataCount = 0;
+            int total = 4096 * 2;
+            int starts[] = new int[32 * 32];
+            int timestamps[] = new int[32 * 32];
+            for(int i = 0 ; i < 32 * 32 ; i++) {
+                starts[i] = dataStream.readInt();
+                timestamps[i] = dataStream.readInt();
+            }
+
+            for(int i = 0 ; i < 32 * 32 ; i++) {
+                if(starts[i] > 0) {
+                    int size = starts[i];
+                    completeDataCount += size;
+                    byte b[] = new byte[size];
+                    dataStream.readFully(b, 0, size);
+
+                    int maxCompressedLength = compressor.maxCompressedLength(size);
+                    byte[] compressed = new byte[maxCompressedLength];
+                    int compressedLength = compressor.compress(b, 0, size, compressed, 0, maxCompressedLength);
+                    b = new byte[compressedLength];
+                    for(int j = 0 ; j < compressedLength ; j++)
+                        b[j] = compressed[j];
+
+                    this.buffer[i] = b;
+                    this.bufferUncompressedSize[i] = size;
+                }
+            }
+        }
+        this.start();
+    }
+
+    private synchronized void markToSave() {
+        synchronized(markedToSaveLock) {
+            markedToSave = true;
+        }
+    }
+
+    private synchronized boolean isMarkedToSave() {
+        synchronized(markedToSaveLock) {
+            if(markedToSave) {
+                markedToSave = false;
+                return true;
+            }
+            return false;
+        }
+    }
+
+    public void run() {
+        try {
+            while(true) {
+                if(markedToSave) {
+                    try {
+                        flush();
+                    } catch(IOException ex) {
+                        LOGGER.error("Region file " + this.regionFile.toAbsolutePath() + " flush failed");
+                    }
+                }
+                for(int i = 0 ; i < 100 ; i++) {
+                    Thread.sleep(100);
+                    if(close) {
+                        return;
+                    }
+                }
+            }
+        } catch(InterruptedException ex) {}
+    }
+
+    public synchronized boolean doesChunkExist(ChunkPos pos) throws Exception {
+        throw new Exception("doesChunkExist is a stub");
+    }
+
+    public synchronized void flush() throws IOException {
+        if(!isMarkedToSave())
+            return;
+
+        long SUPERBLOCK = -4323716122432332390L;
+        byte VERSION = 1;
+        long timestamp = System.currentTimeMillis() / 1000L;
+        short chunkCount = 0;
+
+        File tempFile = new File(regionFile.toString() + ".tmp");
+        FileOutputStream fileStream = new FileOutputStream(tempFile);
+
+        ByteArrayOutputStream zstdByteArray = new ByteArrayOutputStream();
+        ZstdOutputStream zstdStream = new ZstdOutputStream(zstdByteArray, COMPRESSION_LEVEL);
+        zstdStream.setChecksum(true);
+        DataOutputStream zstdDataStream = new DataOutputStream(zstdStream);
+        DataOutputStream dataStream = new DataOutputStream(fileStream);
+
+        dataStream.writeLong(SUPERBLOCK);
+        dataStream.writeByte(VERSION);
+        dataStream.writeLong(timestamp);
+        dataStream.writeByte(COMPRESSION_LEVEL);
+
+        int region_total = 0;
+        int region_raw = 0;
+
+        LZ4FastDecompressor decompressor = LZ4Factory.fastestInstance().fastDecompressor();
+
+        ArrayList<byte[]> byteBuffers = new ArrayList<byte[]>();
+        for(int i = 0 ; i < 32 * 32 ; i++) {
+            if(this.bufferUncompressedSize[i] != 0) {
+                chunkCount += 1;
+                long compStart = System.nanoTime();
+                byte[] content = new byte[bufferUncompressedSize[i]];
+                decompressor.decompress(buffer[i], 0, content, 0, bufferUncompressedSize[i]);
+
+                region_total += buffer[i].length;
+                region_raw += content.length;
+
+                byteBuffers.add(content);
+            } else byteBuffers.add(null);
+        }
+        for(int i = 0 ; i < 32 * 32 ; i++) {
+            zstdDataStream.writeInt(this.bufferUncompressedSize[i]);
+            zstdDataStream.writeInt(0);
+        }
+        for(int i = 0 ; i < 32 * 32 ; i++) {
+            if(byteBuffers.get(i) != null)
+                zstdDataStream.write(byteBuffers.get(i), 0, byteBuffers.get(i).length);
+        }
+        zstdDataStream.close();
+
+        dataStream.writeShort(chunkCount);
+
+        byte[] compressed = zstdByteArray.toByteArray();
+
+        dataStream.writeInt(compressed.length);
+        dataStream.writeLong(XXHashFactory.fastestInstance().hash64().hash(compressed, 0, compressed.length, 0)); // TODO: Hash the contents, not the whole thing
+
+        dataStream.write(compressed, 0, compressed.length);
+        dataStream.writeLong(SUPERBLOCK);
+
+        dataStream.close();
+
+        fileStream.close();
+        Files.move(tempFile.toPath(), this.regionFile, StandardCopyOption.REPLACE_EXISTING);
+    }
+
+    public void setStatus(int x, int z, ChunkStatus status) {
+        this.statuses[this.getChunkIndex(x, z)] = status;
+    }
+
+    public synchronized void write(ChunkPos pos, ByteBuffer buffer) {
+        LZ4Compressor compressor = LZ4Factory.fastestInstance().fastCompressor();
+        try {
+            byte[] b = toByteArray(new ByteArrayInputStream(buffer.array()));
+            int uncompressedSize = b.length;
+
+            int maxCompressedLength = compressor.maxCompressedLength(b.length);
+            byte[] compressed = new byte[maxCompressedLength];
+            int compressedLength = compressor.compress(b, 0, b.length, compressed, 0, maxCompressedLength);
+            b = new byte[compressedLength];
+            for(int j = 0 ; j < compressedLength ; j++)
+                b[j] = compressed[j];
+
+            this.buffer[getChunkIndex(pos.x, pos.z)] = b;
+            this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] = uncompressedSize;
+        } catch (IOException e) {
+            LOGGER.error("Chunk write IOException " + e.toString() + " " + this.regionFile);
+        }
+
+        markToSave();
+    }
+
+    public DataOutputStream getChunkDataOutputStream(ChunkPos pos) throws IOException {
+        return new DataOutputStream(new BufferedOutputStream(new LinearRegionFile.ChunkBuffer(pos)));
+    }
+
+    private class ChunkBuffer extends ByteArrayOutputStream {
+
+        private final ChunkPos pos;
+
+        public ChunkBuffer(ChunkPos chunkcoordintpair) {
+            super();
+            this.pos = chunkcoordintpair;
+        }
+
+        public void close() throws IOException {
+            ByteBuffer bytebuffer = ByteBuffer.wrap(this.buf, 0, this.count);
+            LinearRegionFile.this.write(this.pos, bytebuffer);
+        }
+    }
+
+    private byte[] toByteArray(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        byte[] tempBuffer = new byte[4096];
+
+        int length;
+        while ((length = in.read(tempBuffer)) >= 0) {
+            out.write(tempBuffer, 0, length);
+        }
+
+        return out.toByteArray();
+    }
+
+    @Nullable
+    public synchronized DataInputStream getChunkDataInputStream(ChunkPos pos) throws IOException {
+        if(this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] != 0) {
+            LZ4FastDecompressor decompressor = LZ4Factory.fastestInstance().fastDecompressor();
+            byte[] content = new byte[bufferUncompressedSize[getChunkIndex(pos.x, pos.z)]];
+            decompressor.decompress(this.buffer[getChunkIndex(pos.x, pos.z)], 0, content, 0, bufferUncompressedSize[getChunkIndex(pos.x, pos.z)]);
+            return new DataInputStream(new ByteArrayInputStream(content));
+        }
+        return null;
+    }
+
+    public ChunkStatus getStatusIfCached(int x, int z) {
+        return this.statuses[this.getChunkIndex(x, z)];
+    }
+
+    public void clear(ChunkPos pos) {
+        int i = this.getChunkIndex(pos.x, pos.z);
+        this.buffer[i] = null;
+        this.bufferUncompressedSize[i] = 0;
+        markToSave();
+    }
+
+    public boolean hasChunk(ChunkPos pos) {
+        return this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] > 0;
+    }
+
+    public void close() throws IOException {
+        close = true;
+        try {
+            flush();
+        } catch(IOException e) {
+            throw new IOException("Region flush IOException " + e.toString() + " " + this.regionFile);
+        }
+    }
+
+    private static int getChunkIndex(int x, int z) {
+        return (x & 31) + (z & 31) * 32;
+    }
+
+    public boolean recalculateHeader() throws IOException { // Fusion
+        return false;
+    }
+
+    public void setOversized(int x, int z, boolean something) {}
+
+    public CompoundTag getOversizedData(int x, int z) throws IOException {
+        throw new IOException("getOversizedData is a stub " + this.regionFile);
+    }
+
+    public boolean isOversized(int x, int z) {
+        return false;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
index a08cde4eefe879adcee7c4118bc38f98c5097ed0..fce1e562949a7aebc3b6cea433f4af9f66362e37 100644
--- a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
+++ b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
@@ -1,5 +1,6 @@
 package io.papermc.paper.chunk.system.io;
 
+import com.github.ipecter.fusion.region.AbstractRegionFile; // Fusion
 import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
 import ca.spottedleaf.concurrentutil.executor.Cancellable;
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
@@ -811,7 +812,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                                                final ChunkDataController taskController) {
         final ChunkPos chunkPos = new ChunkPos(chunkX, chunkZ);
         if (intendingToBlock) {
-            return taskController.computeForRegionFile(chunkX, chunkZ, true, (final RegionFile file) -> {
+            return taskController.computeForRegionFile(chunkX, chunkZ, true, (final AbstractRegionFile file) -> { // Fusion
                 if (file == null) { // null if no regionfile exists
                     return Boolean.FALSE;
                 }
@@ -819,7 +820,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                 return file.hasChunk(chunkPos) ? Boolean.TRUE : Boolean.FALSE;
             });
         } else {
-            return taskController.computeForRegionFileIfLoaded(chunkX, chunkZ, (final RegionFile file) -> {
+            return taskController.computeForRegionFileIfLoaded(chunkX, chunkZ, (final AbstractRegionFile file) -> { // Fusion
                 if (file == null) { // null if not loaded
                     return Boolean.TRUE;
                 }
@@ -1116,9 +1117,9 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
             return !this.tasks.isEmpty();
         }
 
-        public <T> T computeForRegionFile(final int chunkX, final int chunkZ, final boolean existingOnly, final Function<RegionFile, T> function) {
+        public <T> T computeForRegionFile(final int chunkX, final int chunkZ, final boolean existingOnly, final Function<AbstractRegionFile, T> function) { // Fusion
             final RegionFileStorage cache = this.getCache();
-            final RegionFile regionFile;
+            final AbstractRegionFile regionFile; // Fusion
             synchronized (cache) {
                 try {
                     regionFile = cache.getRegionFile(new ChunkPos(chunkX, chunkZ), existingOnly, true);
@@ -1131,19 +1132,19 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                 return function.apply(regionFile);
             } finally {
                 if (regionFile != null) {
-                    regionFile.fileLock.unlock();
+                    regionFile.getFileLock().unlock(); // Fusion
                 }
             }
         }
 
-        public <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<RegionFile, T> function) {
+        public <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<AbstractRegionFile, T> function) { // Fusion
             final RegionFileStorage cache = this.getCache();
-            final RegionFile regionFile;
+            final AbstractRegionFile regionFile; // Fusion
 
             synchronized (cache) {
                 regionFile = cache.getRegionFileIfLoaded(new ChunkPos(chunkX, chunkZ));
                 if (regionFile != null) {
-                    regionFile.fileLock.lock();
+                    regionFile.getFileLock().lock(); // Fusion
                 }
             }
 
@@ -1151,7 +1152,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                 return function.apply(regionFile);
             } finally {
                 if (regionFile != null) {
-                    regionFile.fileLock.unlock();
+                    regionFile.getFileLock().unlock(); // Fusion
                 }
             }
         }
@@ -1287,6 +1288,12 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                 } catch (final ThreadDeath thr) {
                     throw thr;
                 } catch (final Throwable thr) {
+                    // Fusion start - Linear region format
+                    if (com.github.ipecter.fusion.FusionConfig.regionFormatName.equals("LINEAR")) {
+                        failedWrite = thr instanceof IOException;
+                        LOGGER.error("Failed to write chunk data for task: " + this.toString(), thr);
+                    } else {
+                    // Fusion end
                     if (thr instanceof RegionFileStorage.RegionFileSizeException) {
                         final int maxSize = RegionFile.MAX_CHUNK_SIZE / (1024 * 1024);
                         LOGGER.error("Chunk at (" + this.chunkX + "," + this.chunkZ + ") in '" + this.world.getWorld().getName() + "' exceeds max size of " + maxSize + "MiB, it has been deleted from disk.");
@@ -1294,6 +1301,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                         failedWrite = thr instanceof IOException;
                         LOGGER.error("Failed to write chunk data for task: " + this.toString(), thr);
                     }
+                    } // Fusion
                 }
 
                 final boolean finalFailWrite = failedWrite;
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 57ab982bfdb9d8893ec8a3cf5ebe49317a952651..aaba8a14c40f879a1047582d1e2dc3d416d51946 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1,6 +1,7 @@
 package net.minecraft.server.level;
 
 import co.aikar.timings.Timing; // Paper
+import com.github.ipecter.fusion.region.AbstractRegionFile; // Fusion
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Iterables;
@@ -952,13 +953,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     // Paper start - chunk status cache "api"
     public ChunkStatus getChunkStatusOnDiskIfCached(ChunkPos chunkPos) {
-        net.minecraft.world.level.chunk.storage.RegionFile regionFile = regionFileCache.getRegionFileIfLoaded(chunkPos);
+        AbstractRegionFile regionFile = regionFileCache.getRegionFileIfLoaded(chunkPos); // Fusion
 
         return regionFile == null ? null : regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
     }
 
     public ChunkStatus getChunkStatusOnDisk(ChunkPos chunkPos) throws IOException {
-        net.minecraft.world.level.chunk.storage.RegionFile regionFile = regionFileCache.getRegionFile(chunkPos, true);
+        AbstractRegionFile regionFile = regionFileCache.getRegionFile(chunkPos, true); // Fusion
 
         if (regionFile == null || !regionFileCache.chunkExists(chunkPos)) {
             return null;
@@ -976,7 +977,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public void updateChunkStatusOnDisk(ChunkPos chunkPos, @Nullable CompoundTag compound) throws IOException {
-        net.minecraft.world.level.chunk.storage.RegionFile regionFile = regionFileCache.getRegionFile(chunkPos, false);
+        AbstractRegionFile regionFile = regionFileCache.getRegionFile(chunkPos, false); // Fusion
 
         regionFile.setStatus(chunkPos.x, chunkPos.z, ChunkSerializer.getStatus(compound));
     }
diff --git a/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java b/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
index 759b125cc1251b9b4f1f443c9f70c482ef5b32f8..912a2b2118156cb3aeddfdd7f7a4cd27a4147550 100644
--- a/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
+++ b/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
@@ -1,5 +1,7 @@
 package net.minecraft.util.worldupdate;
 
+import com.github.ipecter.fusion.region.AbstractRegionFile; // Fusion
+import com.github.ipecter.fusion.region.AbstractRegionFileFactory; // Fusion
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMap.Builder;
@@ -61,10 +63,17 @@ public class WorldUpgrader {
     private volatile int skipped;
     private final Object2FloatMap<ResourceKey<LevelStem>> progressMap = Object2FloatMaps.synchronize(new Object2FloatOpenCustomHashMap(Util.identityStrategy())); // CraftBukkit
     private volatile Component status = Component.translatable("optimizeWorld.stage.counting");
-    public static final Pattern REGEX = Pattern.compile("^r\\.(-?[0-9]+)\\.(-?[0-9]+)\\.mca$");
+    public static Pattern REGEX; // Fusion
     private final DimensionDataStorage overworldDataStorage;
 
     public WorldUpgrader(LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, Registry<LevelStem> dimensionOptionsRegistry, boolean eraseCache) {
+        // Fusion start
+        if (com.github.ipecter.fusion.FusionConfig.regionFormatName.equals("LINEAR")) {
+            this.REGEX = Pattern.compile("^r\\.(-?[0-9]+)\\.(-?[0-9]+)\\.linear$");
+        } else {
+            this.REGEX = Pattern.compile("^r\\.(-?[0-9]+)\\.(-?[0-9]+)\\.mca$");
+        }
+        // Fusion end
         this.dimensions = dimensionOptionsRegistry;
         this.levels = (Set) dimensionOptionsRegistry.registryKeySet().stream().collect(Collectors.toUnmodifiableSet()); // CraftBukkit
         this.eraseCache = eraseCache;
@@ -235,6 +244,11 @@ public class WorldUpgrader {
         File file = this.levelStorage.getDimensionPath((ResourceKey) null).toFile(); // CraftBukkit
         File file1 = new File(file, "region");
         File[] afile = file1.listFiles((file2, s) -> {
+            // Fusion start
+            if (com.github.ipecter.fusion.FusionConfig.regionFormatName.equals("LINEAR")) {
+                return s.endsWith(".linear");
+            }
+            // Fusion end
             return s.endsWith(".mca");
         });
 
@@ -254,7 +268,7 @@ public class WorldUpgrader {
                     int l = Integer.parseInt(matcher.group(2)) << 5;
 
                     try {
-                        RegionFile regionfile = new RegionFile(file2.toPath(), file1.toPath(), true);
+                        AbstractRegionFile regionfile = AbstractRegionFileFactory.getAbstractRegionFile(file2.toPath(), file1.toPath(), true); // Fusion
 
                         try {
                             for (int i1 = 0; i1 < 32; ++i1) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index dcfe090c269d4cbcc2eb1b6f85392848bb34656c..89e03c4510deab622eee2b17aedb5a30b0b0a99b 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -1,6 +1,7 @@
 // mc-dev import
 package net.minecraft.world.level.chunk.storage;
 
+import com.github.ipecter.fusion.region.AbstractRegionFile; // Fusion
 import com.google.common.annotations.VisibleForTesting;
 import com.mojang.logging.LogUtils;
 import java.io.ByteArrayInputStream;
@@ -27,7 +28,7 @@ import net.minecraft.nbt.NbtIo;
 import net.minecraft.world.level.ChunkPos;
 import org.slf4j.Logger;
 
-public class RegionFile implements AutoCloseable {
+public class RegionFile implements AutoCloseable, AbstractRegionFile { // Fusion
 
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int SECTOR_BYTES = 4096;
@@ -51,6 +52,16 @@ public class RegionFile implements AutoCloseable {
     public final java.util.concurrent.locks.ReentrantLock fileLock = new java.util.concurrent.locks.ReentrantLock(true); // Paper
     public final Path regionFile; // Paper
 
+    // Fusion start - Getters
+    public Path getRegionFile() {
+        return this.regionFile;
+    }
+
+    public java.util.concurrent.locks.ReentrantLock getFileLock() {
+        return this.fileLock;
+    }
+    // Fusion end
+
     // Paper start - try to recover from RegionFile header corruption
     private static long roundToSectors(long bytes) {
         long sectors = bytes >>> 12; // 4096 = 2^12
@@ -129,7 +140,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     // note: only call for CHUNK regionfiles
-    boolean recalculateHeader() throws IOException {
+    public boolean recalculateHeader() throws IOException { // Fusion
         if (!this.canRecalcHeader) {
             return false;
         }
@@ -955,10 +966,10 @@ public class RegionFile implements AutoCloseable {
     private static int getChunkIndex(int x, int z) {
         return (x & 31) + (z & 31) * 32;
     }
-    synchronized boolean isOversized(int x, int z) {
+    public synchronized boolean isOversized(int x, int z) { // Fusion
         return this.oversized[getChunkIndex(x, z)] == 1;
     }
-    synchronized void setOversized(int x, int z, boolean oversized) throws IOException {
+    public synchronized void setOversized(int x, int z, boolean oversized) throws IOException { // Fusion
         final int offset = getChunkIndex(x, z);
         boolean previous = this.oversized[offset] == 1;
         this.oversized[offset] = (byte) (oversized ? 1 : 0);
@@ -997,7 +1008,7 @@ public class RegionFile implements AutoCloseable {
         return this.regionFile.getParent().resolve(this.regionFile.getFileName().toString().replaceAll("\\.mca$", "") + "_oversized_" + x + "_" + z + ".nbt");
     }
 
-    synchronized CompoundTag getOversizedData(int x, int z) throws IOException {
+    public synchronized CompoundTag getOversizedData(int x, int z) throws IOException { // Fusion
         Path file = getOversizedFile(x, z);
         try (DataInputStream out = new DataInputStream(new java.io.BufferedInputStream(new InflaterInputStream(Files.newInputStream(file))))) {
             return NbtIo.read((java.io.DataInput) out);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index bd502ca721de0cab438d995efa00ad0554c0d2fe..a42bf8bde53b089a70af7ddbb76f4f74a6106efb 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -1,5 +1,7 @@
 package net.minecraft.world.level.chunk.storage;
 
+import com.github.ipecter.fusion.region.AbstractRegionFile; // Fusion
+import com.github.ipecter.fusion.region.AbstractRegionFileFactory; // Fusion
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.DataInput;
@@ -21,8 +23,9 @@ import net.minecraft.world.level.ChunkPos;
 public class RegionFileStorage implements AutoCloseable {
 
     public static final String ANVIL_EXTENSION = ".mca";
+    public static final String LINEAR_EXTENSION = ".linear"; // Fusion
     private static final int MAX_CACHE_SIZE = 256;
-    public final Long2ObjectLinkedOpenHashMap<RegionFile> regionCache = new Long2ObjectLinkedOpenHashMap();
+    public final Long2ObjectLinkedOpenHashMap<AbstractRegionFile> regionCache = new Long2ObjectLinkedOpenHashMap(); // Fusion
     private final Path folder;
     private final boolean sync;
 
@@ -42,9 +45,17 @@ public class RegionFileStorage implements AutoCloseable {
     // Paper start
     public static @Nullable ChunkPos getRegionFileCoordinates(Path file) {
         String fileName = file.getFileName().toString();
+        // Fusion start
+        if (com.github.ipecter.fusion.FusionConfig.regionFormatName.equals("LINEAR")) {
+            if (!fileName.startsWith("r.") || !fileName.endsWith(".linear")) {
+                return null;
+            }
+        } else {
+        // Fusion end
         if (!fileName.startsWith("r.") || !fileName.endsWith(".mca")) {
             return null;
         }
+        } // Fusion
 
         String[] split = fileName.split("\\.");
 
@@ -62,49 +73,56 @@ public class RegionFileStorage implements AutoCloseable {
         }
     }
 
-    public synchronized RegionFile getRegionFileIfLoaded(ChunkPos chunkcoordintpair) {
+    public synchronized AbstractRegionFile getRegionFileIfLoaded(ChunkPos chunkcoordintpair) { // Fusion
         return this.regionCache.getAndMoveToFirst(ChunkPos.asLong(chunkcoordintpair.getRegionX(), chunkcoordintpair.getRegionZ()));
     }
 
     public synchronized boolean chunkExists(ChunkPos pos) throws IOException {
-        RegionFile regionfile = getRegionFile(pos, true);
+        AbstractRegionFile regionfile = getRegionFile(pos, true); // Fusion
 
         return regionfile != null ? regionfile.hasChunk(pos) : false;
     }
 
-    public synchronized RegionFile getRegionFile(ChunkPos chunkcoordintpair, boolean existingOnly) throws IOException { // CraftBukkit
+    public synchronized AbstractRegionFile getRegionFile(ChunkPos chunkcoordintpair, boolean existingOnly) throws IOException { // CraftBukkit // Fusion
         return this.getRegionFile(chunkcoordintpair, existingOnly, false);
     }
-    public synchronized RegionFile getRegionFile(ChunkPos chunkcoordintpair, boolean existingOnly, boolean lock) throws IOException {
+    public synchronized AbstractRegionFile getRegionFile(ChunkPos chunkcoordintpair, boolean existingOnly, boolean lock) throws IOException { // Fusion
         // Paper end
         long i = ChunkPos.asLong(chunkcoordintpair.getRegionX(), chunkcoordintpair.getRegionZ());
-        RegionFile regionfile = (RegionFile) this.regionCache.getAndMoveToFirst(i);
+        AbstractRegionFile regionfile = (AbstractRegionFile) this.regionCache.getAndMoveToFirst(i); // Fusion
 
         if (regionfile != null) {
             // Paper start
             if (lock) {
                 // must be in this synchronized block
-                regionfile.fileLock.lock();
+                regionfile.getFileLock().lock(); // Fusion
             }
             // Paper end
             return regionfile;
         } else {
             if (this.regionCache.size() >= io.papermc.paper.configuration.GlobalConfiguration.get().misc.regionFileCacheSize) { // Paper - configurable
-                ((RegionFile) this.regionCache.removeLast()).close();
+                ((AbstractRegionFile) this.regionCache.removeLast()).close(); // Fusion
             }
 
             FileUtil.createDirectoriesSafe(this.folder);
             Path path = this.folder;
             int j = chunkcoordintpair.getRegionX();
-            Path path1 = path.resolve("r." + j + "." + chunkcoordintpair.getRegionZ() + ".mca"); // Paper - diff on change
+            // Fusion start
+            Path path1;
+            if (com.github.ipecter.fusion.FusionConfig.regionFormatName.equals("LINEAR")) {
+                path1 = path.resolve("r." + j + "." + chunkcoordintpair.getRegionZ() + ".linear");
+            } else {
+                path1 = path.resolve("r." + j + "." + chunkcoordintpair.getRegionZ() + ".mca"); // Paper - diff on change
+            }
+            // Fusion end
             if (existingOnly && !java.nio.file.Files.exists(path1)) return null; // CraftBukkit
-            RegionFile regionfile1 = new RegionFile(path1, this.folder, this.sync, this.isChunkData); // Paper - allow for chunk regionfiles to regen header
+            AbstractRegionFile regionfile1 = AbstractRegionFileFactory.getAbstractRegionFile(path1, this.folder, this.sync, this.isChunkData); // Paper - allow for chunk regionfiles to regen header // Fusion
 
             this.regionCache.putAndMoveToFirst(i, regionfile1);
             // Paper start
             if (lock) {
                 // must be in this synchronized block
-                regionfile1.fileLock.lock();
+                regionfile1.getFileLock().lock(); // Fusion
             }
             // Paper end
             return regionfile1;
@@ -132,7 +150,7 @@ public class RegionFileStorage implements AutoCloseable {
     }
 
 
-    private static CompoundTag readOversizedChunk(RegionFile regionfile, ChunkPos chunkCoordinate) throws IOException {
+    private static CompoundTag readOversizedChunk(AbstractRegionFile regionfile, ChunkPos chunkCoordinate) throws IOException { // Fusion
         synchronized (regionfile) {
             try (DataInputStream datainputstream = regionfile.getChunkDataInputStream(chunkCoordinate)) {
                 CompoundTag oversizedData = regionfile.getOversizedData(chunkCoordinate.x, chunkCoordinate.z);
@@ -179,14 +197,14 @@ public class RegionFileStorage implements AutoCloseable {
     @Nullable
     public CompoundTag read(ChunkPos pos) throws IOException {
         // CraftBukkit start - SPIGOT-5680: There's no good reason to preemptively create files on read, save that for writing
-        RegionFile regionfile = this.getRegionFile(pos, true, true); // Paper
+        AbstractRegionFile regionfile = this.getRegionFile(pos, true, true); // Paper // Fusion
         if (regionfile == null) {
             return null;
         }
         // Paper start - Add regionfile parameter
         return this.read(pos, regionfile);
     }
-    public CompoundTag read(ChunkPos pos, RegionFile regionfile) throws IOException {
+    public CompoundTag read(ChunkPos pos, AbstractRegionFile regionfile) throws IOException { // Fusion
         // We add the regionfile parameter to avoid the potential deadlock (on fileLock) if we went back to obtain a regionfile
         // if we decide to re-read
         // Paper end
@@ -196,7 +214,7 @@ public class RegionFileStorage implements AutoCloseable {
 
         // Paper start
         if (regionfile.isOversized(pos.x, pos.z)) {
-            printOversizedLog("Loading Oversized Chunk!", regionfile.regionFile, pos.x, pos.z);
+            printOversizedLog("Loading Oversized Chunk!", regionfile.getRegionFile(), pos.x, pos.z); // Fusion
             return readOversizedChunk(regionfile, pos);
         }
         // Paper end
@@ -210,12 +228,12 @@ public class RegionFileStorage implements AutoCloseable {
                     if (this.isChunkData) {
                         ChunkPos chunkPos = ChunkSerializer.getChunkCoordinate(nbttagcompound);
                         if (!chunkPos.equals(pos)) {
-                            net.minecraft.server.MinecraftServer.LOGGER.error("Attempting to read chunk data at " + pos + " but got chunk data for " + chunkPos + " instead! Attempting regionfile recalculation for regionfile " + regionfile.regionFile.toAbsolutePath());
+                            net.minecraft.server.MinecraftServer.LOGGER.error("Attempting to read chunk data at " + pos + " but got chunk data for " + chunkPos + " instead! Attempting regionfile recalculation for regionfile " + regionfile.getRegionFile().toAbsolutePath()); // Fusion
                             if (regionfile.recalculateHeader()) {
-                                regionfile.fileLock.lock(); // otherwise we will unlock twice and only lock once.
+                                regionfile.getFileLock().lock(); // otherwise we will unlock twice and only lock once. // Fusion
                                 return this.read(pos, regionfile);
                             }
-                            net.minecraft.server.MinecraftServer.LOGGER.error("Can't recalculate regionfile header, regenerating chunk " + pos + " for " + regionfile.regionFile.toAbsolutePath());
+                            net.minecraft.server.MinecraftServer.LOGGER.error("Can't recalculate regionfile header, regenerating chunk " + pos + " for " + regionfile.getRegionFile().toAbsolutePath()); // Fusion
                             return null;
                         }
                     }
@@ -249,13 +267,13 @@ public class RegionFileStorage implements AutoCloseable {
 
         return nbttagcompound;
         } finally { // Paper start
-            regionfile.fileLock.unlock();
+            regionfile.getFileLock().unlock(); // Fusion
         } // Paper end
     }
 
     public void scanChunk(ChunkPos chunkPos, StreamTagVisitor scanner) throws IOException {
         // CraftBukkit start - SPIGOT-5680: There's no good reason to preemptively create files on read, save that for writing
-        RegionFile regionfile = this.getRegionFile(chunkPos, true);
+        AbstractRegionFile regionfile = this.getRegionFile(chunkPos, true); // Fusion
         if (regionfile == null) {
             return;
         }
@@ -285,7 +303,7 @@ public class RegionFileStorage implements AutoCloseable {
     }
 
     protected void write(ChunkPos pos, @Nullable CompoundTag nbt) throws IOException {
-        RegionFile regionfile = this.getRegionFile(pos, nbt == null, true); // CraftBukkit // Paper // Paper start - rewrite chunk system
+        AbstractRegionFile regionfile = this.getRegionFile(pos, nbt == null, true); // CraftBukkit // Paper // Paper start - rewrite chunk system // Fusion
         if (nbt == null && regionfile == null) {
             return;
         }
@@ -335,7 +353,7 @@ public class RegionFileStorage implements AutoCloseable {
         }
         // Paper end
         } finally { // Paper start
-            regionfile.fileLock.unlock();
+            regionfile.getFileLock().unlock(); // Fusion
         } // Paper end
     }
 
@@ -344,7 +362,7 @@ public class RegionFileStorage implements AutoCloseable {
         ObjectIterator objectiterator = this.regionCache.values().iterator();
 
         while (objectiterator.hasNext()) {
-            RegionFile regionfile = (RegionFile) objectiterator.next();
+            AbstractRegionFile regionfile = (AbstractRegionFile) objectiterator.next(); // Fusion
 
             try {
                 regionfile.close();
@@ -360,7 +378,7 @@ public class RegionFileStorage implements AutoCloseable {
         ObjectIterator objectiterator = this.regionCache.values().iterator();
 
         while (objectiterator.hasNext()) {
-            RegionFile regionfile = (RegionFile) objectiterator.next();
+            AbstractRegionFile regionfile = (AbstractRegionFile) objectiterator.next(); // Fusion
 
             regionfile.flush();
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index b17bc6482d2bd97d2e48d3967dea72605cf13164..31d5de3d24de3120003eb2b8e57b96f3f3e01be0 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit;
 
+import com.github.ipecter.fusion.region.AbstractRegionFile; // Fusion
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
@@ -552,7 +553,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
                 return true;
             }
 
-            net.minecraft.world.level.chunk.storage.RegionFile file;
+            AbstractRegionFile file; // Fusion
             try {
                 file = world.getChunkSource().chunkMap.regionFileCache.getRegionFile(chunkPos, false);
             } catch (java.io.IOException ex) {
